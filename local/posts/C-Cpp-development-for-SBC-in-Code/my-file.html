<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>Komputery jednopłytkowe (ang. <code class="language-plaintext highlighter-rouge">SBC</code> — <code class="language-plaintext highlighter-rouge">Single Board Computer</code>) to uniwersalne urządzenia mikroprocesorowe pracujące pod kontrolą systemu operacyjnego.
Zazwyczaj systemem tym jest Linux.
Architektury komputerów jednopłytkowych mogą istotnie się różnić od architektur stosowanych dla komputerów osobistych.
W rezultacie przygotowanie aplikacji w postaci binarnej na urządzenie docelowe (<code class="language-plaintext highlighter-rouge">target</code>) na komputerze osobistym (<code class="language-plaintext highlighter-rouge">host</code>) wymaga wielu, często dość skomplikowanych, zabiegów.
Uwaga niniejszego opracowania skupiona jest na realizacji różnych scenariuszy pracy z wykorzystaniem edytora <code class="language-plaintext highlighter-rouge">VS Code</code> i eliminujących konieczność instalacji i konfiguracji środowiska graficznego na <code class="language-plaintext highlighter-rouge">SBC</code>.</p>

<!--more-->

<p>Producenci urządzeń klasy <code class="language-plaintext highlighter-rouge">SBC</code> nieustannie przekonują potencjalnych nabywców, że urządzenia te mogą funkcjonować jako ubogie wersje komputerów osobistych, jednak nie znam nikogo, kto używałby ich w ten sposób.
Tak naprawdę siłą komputerów tego typu jest dostępność niskopoziomowych interfejsów takich, jak linie <code class="language-plaintext highlighter-rouge">GPIO</code> czy magistrale <code class="language-plaintext highlighter-rouge">I2C</code>, <code class="language-plaintext highlighter-rouge">SPI</code> przy jednoczesnej dostępności wielu serwisów sieciowych.
Jądro systemu operacyjnego zainstalowanego na takim urządzeniu zapewnia abstrakcyjny interfejs dostępu sprzętu, dzięki czemu aplikacje wyglądają w zasadzie tak samo, niezależnie od platformy sprzętowej wykorzystanej do realizacji urządzenia <code class="language-plaintext highlighter-rouge">SBC</code>.</p>

<p>Idealną sytuacją byłoby, gdyby aplikacje dla komputera jednopłytkowego można było tworzyć, budować i uruchamiać bezpośrednio na nim. Komfortowa praca wymaga jednak uruchomienia konsoli graficznej (instalacji oprogramowania oraz doposażenia w dodatkowy sprzęt w postaci myszy, klawiatury i monitora), zapewnienia odpowiedniej przestrzeni dyskowej i wystarczającego rozmiaru pamięci RAM.
Scenariusz taki jest możliwy, gdy <code class="language-plaintext highlighter-rouge">SBC</code> ma zasoby porównywalne z komputerami <code class="language-plaintext highlighter-rouge">PC</code>.
W zdecydowanej większości przypadków tak nie jest.</p>

<p>We wszystkich opisanych dalej scenariuszach <code class="language-plaintext highlighter-rouge">jedynym</code> interfejsem programisty będzie
<a href="https://code.visualstudio.com/"><code class="language-plaintext highlighter-rouge">Visual Studio Code</code></a> – doceniony przez programistów i wysoce konfigurowalny edytor.
Mechanizm rozszerzeń w edytorze umożliwia jego uzupełnienie o funkcje budowania i uruchamiania aplikacji co <code class="language-plaintext highlighter-rouge">de facto</code> przekształca go w zintegrowane środowisko pracy. 
<code class="language-plaintext highlighter-rouge">VS Code</code> jest dostępny nieodpłatnie na wszystkie popularne systemy operacyjne. 
Pracę z projektami C/C++ znacznie ułatwia <code class="language-plaintext highlighter-rouge">C/C++ Extension Pack</code>. 
Dalej przyjęto, że rozszerzenie to jest zainstalowane.
Rozważane są scenariusze pracy w których kod aplikacji jest budowany na urządzeniu docelowym lub komputerze <code class="language-plaintext highlighter-rouge">PC</code>.</p>

<h2 id="1-kompilacja-natywna">1. Kompilacja natywna</h2>

<p>Opisane w tym punkcie scenariusze wymagają instalacji w systemie <code class="language-plaintext highlighter-rouge">target</code> narzędzi umożliwiających budowanie aplikacji, np.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre>apt <span class="nb">install</span> <span class="nt">-y</span> build-essentials make
apt <span class="nb">install</span> <span class="nt">-y</span> libgpiod-dev
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">VS Code</code> jest wykorzystywane jedynie do zapewnienia programiście wygodnego interfejsu graficznego.</p>

<h3 id="11-praca-zdalna-z-wykorzystaniem-code-server">1.1 Praca zdalna z wykorzystaniem <code class="language-plaintext highlighter-rouge">Code Server</code>
</h3>

<p>Instalacja w <code class="language-plaintext highlighter-rouge">Visual Studio Code</code> rozszerzenia <code class="language-plaintext highlighter-rouge">Remote SSH</code> umożliwia pracę zdalną na dowolnym koncie <code class="language-plaintext highlighter-rouge">SSH</code>, tak jak gdyby był to komputer lokalny. W procesie automatycznej konfiguracji zdalnego konta na systemie <code class="language-plaintext highlighter-rouge">target</code> jest instalowany i uruchamiany <a href="https://code.visualstudio.com/docs/remote/vscode-server"><code class="language-plaintext highlighter-rouge">Code Server</code></a>.
Otwarcie zdalnej sesji przebiega następująco:</p>

<ul>
  <li>
    <p>po uruchomieniu <code class="language-plaintext highlighter-rouge">Visual Studio Code</code> wystarczy wybrać zielony przycisk “<img src="connect-button.png" alt="connect-button">” w lewym dolnym rogu ekranu</p>
  </li>
  <li>
    <p>z palety komend wybrać “<code class="language-plaintext highlighter-rouge">Connect to Host</code>”,</p>
  </li>
  <li>
    <p>w polu adresu wpisać <code class="language-plaintext highlighter-rouge">root@opi.usb</code> (“root” można zamienić na dowolne inne konto, <code class="language-plaintext highlighter-rouge">opi.usb"</code> jest nazwą sieciową systemu <code class="language-plaintext highlighter-rouge">target</code> i może być zamieniona na stosowny numer IP),</p>
  </li>
</ul>

<p>Rozszerzenie <code class="language-plaintext highlighter-rouge">Remote SSH</code> automatycznie zainstaluje na zdalnym koncie oprogramowanie <code class="language-plaintext highlighter-rouge">Code Server</code> (w katalogu ‘.vscode’ na zdalnym koncie) umożliwiające egzekucję i odbieranie wyników komend wydawanych w tunelu SSH.
Praca w takiej konfiguracji jest bardzo wygodna i w zasadzie niczym nie różni się od pracy lokalnej. Jedyna różnica polega na tym, że źródła aplikacji i narzędzia ich kompilacji muszą być obecne na systemie <code class="language-plaintext highlighter-rouge">target</code>. Na systemie <code class="language-plaintext highlighter-rouge">host</code> nie trzeba instalować nić oprócz <code class="language-plaintext highlighter-rouge">Visual Studio Code</code>.
Niestety, przedstawione rozwiązanie ma dwie (poważne) wady:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">code-server</code> wspiera tylko architektury 64-bitowe: <code class="language-plaintext highlighter-rouge">amd64</code> i <code class="language-plaintext highlighter-rouge">arm64</code>, co na wyklucza zastosowanie tego podejścia na wielu dostępnych na rynku <code class="language-plaintext highlighter-rouge">SBC</code>,</p>
  </li>
  <li>
    <p>system <code class="language-plaintext highlighter-rouge">target</code> powinien być wyposażony w 1GB RAM i dwurdzeniowy CPU.</p>
  </li>
</ul>

<h3 id="12-praca-zdalna-w-tunelu-ssh">1.2 Praca zdalna w tunelu SSH</h3>

<p>Poprzednia metoda nie jest uniwersalna ze względu na wymagania stawiane przez <code class="language-plaintext highlighter-rouge">Code Server</code>.
Element ten można wyeliminować z poprzedniego schematu.
Tym razem pliki źródłowe są edytowane na systemie <code class="language-plaintext highlighter-rouge">host</code> i przed kompilacją kopiowane na system <code class="language-plaintext highlighter-rouge">target</code>, gdzie są kompilowane za pomocą natywnych narzędzi.
W toku dalszego wywodu zostanie przyjęto następującą strukturę podkatalogów w katalogu projektu</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="rouge-code"><pre>.vscode/ -&gt; katalog z plikami konfiguracyjnymi IDE
obj/ -&gt; katalog pomocniczy dla make
src/ -&gt; pliki źródłowe projektu
src/include/
src/main.c
Makefile 
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Powyższy projekt można zbudować natywnie, korzystając z następującego <code class="language-plaintext highlighter-rouge">Makefile</code> x</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td>
<td class="rouge-code"><pre><span class="c"># Compiler settings - Can be customized.</span>
CC <span class="o">=</span> gcc
CXX <span class="o">=</span> g++
CPPFLAGS <span class="o">=</span>
CFLAGS <span class="o">=</span> <span class="nt">-std</span><span class="o">=</span>c11 <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-fdiagnostics-color</span><span class="o">=</span>always
CXXFLAGS <span class="o">=</span> <span class="nt">-std</span><span class="o">=</span>c++11 <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-fdiagnostics-color</span><span class="o">=</span>always
LDFLAGS <span class="o">=</span> <span class="nt">-lpthread</span> <span class="nt">-lgpiod</span>

<span class="c"># Makefile settings - Can be customized.</span>
APPNAME <span class="o">=</span> main
EXT <span class="o">=</span> .c
SRCDIR <span class="o">=</span> src
OBJDIR <span class="o">=</span> obj
REMOTE <span class="o">=</span> root@opi.usb
REMOTEPWD <span class="o">=</span> /root/RemotePowerButton

SRC <span class="o">=</span> <span class="si">$(</span>wildcard <span class="si">$(</span>SRCDIR<span class="si">)</span>/<span class="k">*</span><span class="si">$(</span>EXT<span class="si">))</span>
OBJ <span class="o">=</span> <span class="si">$(</span>SRC:<span class="si">$(</span>SRCDIR<span class="si">)</span>/%<span class="si">$(</span>EXT<span class="si">)</span><span class="o">=</span><span class="si">$(</span>OBJDIR<span class="si">)</span>/%.o<span class="si">)</span>
DEP <span class="o">=</span> <span class="si">$(</span>OBJ:<span class="si">$(</span>OBJDIR<span class="si">)</span>/%.o<span class="o">=</span>%.d<span class="si">)</span>

RM <span class="o">=</span> <span class="nb">rm

</span>all: <span class="si">$(</span>APPNAME<span class="si">)</span>

<span class="c"># Copy sources to target</span>
copysrc:
  scp <span class="nt">-p</span> <span class="nt">-r</span> ./src/ ./obj/ ./Makefile <span class="si">$(</span>REMOTE<span class="si">)</span>:<span class="si">$(</span>REMOTEPWD<span class="si">)</span>

<span class="c"># Builds the app</span>
<span class="si">$(</span>APPNAME<span class="si">)</span>: <span class="si">$(</span>OBJ<span class="si">)</span>
  <span class="si">$(</span>CC<span class="si">)</span> <span class="si">$(</span>CFLAGS<span class="si">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nv">$^</span> <span class="si">$(</span>LDFLAGS<span class="si">)</span>

<span class="c"># Creates the dependecy rules</span>
%.d: <span class="si">$(</span>SRCDIR<span class="si">)</span>/%<span class="si">$(</span>EXT<span class="si">)</span>
  @<span class="si">$(</span>CPP<span class="si">)</span> <span class="si">$(</span>CFLAGS<span class="si">)</span> <span class="si">$(</span>CPPFLAGS<span class="si">)</span> <span class="nv">$&lt;</span> <span class="nt">-MM</span> <span class="nt">-MT</span> <span class="si">$(</span>@:%.d<span class="o">=</span><span class="si">$(</span>OBJDIR<span class="si">)</span>/%.o<span class="si">)</span> <span class="o">&gt;</span><span class="nv">$@</span>

<span class="c"># Includes all .h files</span>
<span class="nt">-include</span> <span class="si">$(</span>DEP<span class="si">)</span>

<span class="c"># Building rule for .o files and its .c/.cpp in combination with all .h</span>
<span class="si">$(</span>OBJDIR<span class="si">)</span>/%.o: <span class="si">$(</span>SRCDIR<span class="si">)</span>/%<span class="si">$(</span>EXT<span class="si">)</span>
  <span class="si">$(</span>CC<span class="si">)</span> <span class="si">$(</span>CFLAGS<span class="si">)</span> <span class="si">$(</span>CPPFLAGS<span class="si">)</span> <span class="nt">-o</span> <span class="nv">$@</span> <span class="nt">-c</span> <span class="nv">$&lt;</span>

<span class="c"># Cleans complete project</span>
.PHONY: clean
clean:
  -<span class="si">$(</span>RM<span class="si">)</span> <span class="si">$(</span>OBJ<span class="si">)</span> <span class="si">$(</span>DEP<span class="si">)</span> <span class="si">$(</span>APPNAME<span class="si">)</span>

<span class="c"># Cleans only all files with the extension .d</span>
.PHONY: cleandep
cleandep:
  -<span class="si">$(</span>RM<span class="si">)</span> <span class="si">$(</span>DEP<span class="si">)</span>
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>W powyższym pliku cel ‘<code class="language-plaintext highlighter-rouge">copysrc</code>’ odpowiada za skopiowanie na system <code class="language-plaintext highlighter-rouge">target</code> struktury katalogów i plików niezbędnych do zbudowania aplikacji.</p>

<p>Plikiem konfiguracyjnym mówiącym <code class="language-plaintext highlighter-rouge">Visual Studio Code</code> jak należy dany projekt budować, jest plik ‘<code class="language-plaintext highlighter-rouge">.vscode/tasks.json</code>’.
Każdy projekt może mieć kilka zadań, do których odwołujemy się przez nazwę nadaną w polu ‘<code class="language-plaintext highlighter-rouge">label</code>’. Zadania budowania konfiguruje się w menu ‘<code class="language-plaintext highlighter-rouge">Terminal</code>’.
Konfiguracja zadania, które kopiuje pliki źródłowe na system <code class="language-plaintext highlighter-rouge">target</code>, a następnie zdalnie wykonuje na nim polecenie ‘<code class="language-plaintext highlighter-rouge">make</code>’ wygląda następująco (plik ‘<code class="language-plaintext highlighter-rouge">.vscode/tasks.json</code>’):</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Native Build on Target"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make copysrc ; ssh root@opi.usb '(cd /root/RemotePowerButton; make)'"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task copies project sources to target and then it builds them natively there."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Przyjęto, że zdalnym katalogiem projektu jest ‘<code class="language-plaintext highlighter-rouge">/root/RemotePowerButton</code>’. Procedurę budowania aktywuje się skrótem klawiszowym ‘<code class="language-plaintext highlighter-rouge">Ctrl+Shift+B</code>’.</p>

<p>Edytor <code class="language-plaintext highlighter-rouge">Visual Studio Code</code> jest wyposażony w mechanizm <a href="https://code.visualstudio.com/docs/editor/intellisense"><code class="language-plaintext highlighter-rouge">IntelliSense</code></a> bardzo ułatwiający pisanie kodu źródłowego poprzez zastosowanie zaawansowanego mechanizmu podpowiedzi nt. zdefiniowanych zmiennych, dostępnych funkcji, akceptowanych przez nie argumentów itp.
<code class="language-plaintext highlighter-rouge">IntelliSense</code> czerpie swoją wiedzę z analizy treści plików nagłówkowych.
W przedstawionej tutaj konfiguracji problem polega na tym, że <code class="language-plaintext highlighter-rouge">IntelliSense</code> korzysta z plików nagłówkowych w systemie <code class="language-plaintext highlighter-rouge">host</code>, które mogą być zupełnie odmienne od odpowiednich plików w systemie <code class="language-plaintext highlighter-rouge">target</code>.
Aby tę niefortunny stan rzeczy naprawić, należy pliki nagłówkowe z systemu <code class="language-plaintext highlighter-rouge">target</code> udostępnić <code class="language-plaintext highlighter-rouge">IntelliSense</code>.
Procedura jest dwuetapowa:</p>

<ol>
  <li>
    <p>pliki nagłówkowe z systemu <code class="language-plaintext highlighter-rouge">target</code>, muszą być widoczne w systemie <code class="language-plaintext highlighter-rouge">host</code>,</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">IntelliSense</code> musi być poinformowane, gdzie się te pliki znajdują.</p>
  </li>
</ol>

<p>Punkt 1. można zrealizować na dwa sposoby:</p>

<ul>
  <li>
    <p>metodą “brutalnej siły” polegającej na skopiowaniu rzeczonych plików nagłówkowych na system <code class="language-plaintext highlighter-rouge">host</code> (przeniesienie atrybutu właściciela pliku nie jest konieczne),</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td>
<td class="rouge-code"><pre><span class="c"># w katalogu projektu na systemie host</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> rootfs/usr/include
scp <span class="nt">-r</span> root@opi.usb:/usr/include rootfs/usr/include/
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>metodą “elegancką” polegającą na <a href="#udost%C4%99pnianie-g%C5%82%C3%B3wnego-systemu-plik%C3%B3w-poprzez-nfs">udostępnieniu w trybie <code class="language-plaintext highlighter-rouge">tylko do odczytu</code> odpowiedniego fragmentu systemu plików systemu <code class="language-plaintext highlighter-rouge">target</code> z wykorzystaniem protokołu NFS</a>.</p>
  </li>
</ul>

<p>Metoda “brutalnej siły” ma tę wadę, że przynajmniej co do zasady, powinna być powtórzona po każdorazowej aktualizacji oprogramowania na systemie <code class="language-plaintext highlighter-rouge">target</code>.
Metodę elegancką opisano w punkcie <a href="#kruczki-i-sztuczki">“Kruczki i sztuczki”</a>.</p>

<p>Następnie, korzystając z pliku ‘<code class="language-plaintext highlighter-rouge">.vscode/c_cpp_properties.json</code>’ należy poinformować <code class="language-plaintext highlighter-rouge">IntelliSense</code>, które pliki powinny być analizowane</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Target Rootfs"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"includePath"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/src/``"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/rootfs/``"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"defines"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">symbols</span><span class="w"> </span><span class="err">resolved</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">preprocessor</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="err">are</span><span class="w"> </span><span class="err">unknown</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">IntelliSense</span><span class="w">
                </span><span class="s2">"NULL=0"</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">I</span><span class="w"> </span><span class="err">suspect</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="s2">"#     define NULL 0"</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">types.h</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">accepted</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">cpp</span><span class="p">,</span><span class="w"> </span><span class="err">but</span><span class="w"> </span><span class="err">IGNORED</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">IntelliSense</span><span class="w"> 
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"compilerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cStandard"</span><span class="p">:</span><span class="w"> </span><span class="s2">"c11"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cppStandard"</span><span class="p">:</span><span class="w"> </span><span class="s2">"c++11"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"intelliSenseMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"linux-gcc-arm64"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Zagadnienie udostępnienia właściwych plików nagłówkowych będzie się przewijało we wszystkich opisywanych dalej konfiguracjach. W wersji korzystającej z plików udostępnionych za pomocą NFS katalog ‘<code class="language-plaintext highlighter-rouge">rootfs</code>’ może być po prostu linkiem symbolicznym do katalogu, w którym widoczne są pliki urządzenia <code class="language-plaintext highlighter-rouge">target</code>.</p>

<h2 id="2-kompilacja-skrośna">2. Kompilacja skrośna</h2>

<p>Proces budowania aplikacji złożony jest dwóch zasadniczych etapów:</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">kompilacji</code>, czyli przekształcenia kodu źródłowego na kod binarny dla docelowej architektury,</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">łączenia</code> (ang. <code class="language-plaintext highlighter-rouge">liniking</code>), czyli zebrania wielu fragmentów kodu binarnego w jedną aplikację.</p>
  </li>
</ul>

<p>Kompilacji podlega kod źródłowy stworzony przez twórcę oprogramowania wraz z kodem zawartym w plikach nagłówkowych bibliotek.
Łączeniu podlega kod binarny wyprodukowany w procesie kompilacji z kodem binarnym bibliotek. Kompilator czerpie z plików nagłówkowych informację o kodzie, który będzie dostępny na etapie łączenia, zatem oba te elementy muszą pozostawać w pełnym synchronizmie.
Sam proces łączenia ma dwie odmiany.
W łączeniu <code class="language-plaintext highlighter-rouge">statycznym</code> wymuszanym na linkerze opcją <code class="language-plaintext highlighter-rouge">-static</code> kod binarny aplikacji oraz wspomagający go kod z bibliotek są ‘sklejane’ w jeden plik.
Tak zbudowana aplikacja jest samowystarczalna, jednak jej kod wynikowy może być bardzo duży (np. użycie funkcji <code class="language-plaintext highlighter-rouge">printf</code> implikuje dołączenie znacznego fragmentu standardowej biblioteki C).
Bez opcji <code class="language-plaintext highlighter-rouge">-static</code> linker pracuje w trybie łączenia <code class="language-plaintext highlighter-rouge">dynamicznego</code>, w którym kod binarny aplikacji jest uzupełniany informacją <code class="language-plaintext highlighter-rouge">o nazwie i wersji biblioteki</code>, o którą powinien być uzupełniony w momencie uruchomienia. Dzięki takiemu podejściu kod wynikowy aplikacji jest stosunkowo mały, a biblioteki wykorzystywane przez wiele aplikacji są ładowane do pamięci tylko raz. Niestety, w momencie uruchomienia aplikacja nie jest samodzielna jak w przypadku łączenia statycznego, gdyż system, w którym jest uruchamiana, musi być uzupełniony o biblioteki współdzielone niezbędne do działania aplikacji (z dokładnością do wersji biblioteki, aby zapewnić zgodność interfejsu biblioteki zakładanego podczas kompilacji).
Ostatecznie budowanie skrośne wymaga spełnienia następujących warunków:</p>

<ol>
  <li>
    <p>kompilator musi wytwarzać kod binarny zgodny z architekturą urządzenia <code class="language-plaintext highlighter-rouge">target</code>,</p>
  </li>
  <li>
    <p>przetwarzane przez kompilator pliki nagłówkowe muszą być zgodne z kodem binarnym łączonym przez linker,</p>
  </li>
  <li>
    <p>na etapie uruchamiania, dla programów łączonych dynamicznie, w systemie <code class="language-plaintext highlighter-rouge">target</code> muszą być zainstalowane <code class="language-plaintext highlighter-rouge">dokładnie te same</code> biblioteki, które były przyjęte na etapie łączenia.
Mówiąc krótko, architektura kodu, deklaracje zawarte w kodach nagłówkowych i biblioteki podczas łączenia i uruchamiania aplikacji <code class="language-plaintext highlighter-rouge">muszą</code> do siebie pasować.</p>
  </li>
</ol>

<p>Podstawowym problemem skrośnego tworzenia oprogramowania jest konstrukcja środowiska gwarantującego spełnienie warunków 1-3.
Ich poprawne spełnienie wymaga istotnej ingerencji w oprogramowanie zainstalowane na systemie <code class="language-plaintext highlighter-rouge">host</code>.
Zestaw narzędzi umożliwiających przygotowanie kodu binarnego na architekturę inną niż architektura systemu na którym wykonywania jest kompilacja nazywa się <code class="language-plaintext highlighter-rouge">toolchain</code>‘em.
Nazwa ta podkreśla fakt, że skrośne budowanie aplikacji wymaga zharmonizowanego użycia wielu narzędzi.</p>

<p><code class="language-plaintext highlighter-rouge">Skrośne budowanie aplikacji jest żmudne i podatne na błędy</code></p>

<h3 id="21-instalacja-kompilatora-skrośnego-w-systemie-host">2.1 Instalacja kompilatora skrośnego w systemie <code class="language-plaintext highlighter-rouge">host</code>
</h3>

<p>Budowanie skrośne jest stosunkowo proste, gdy dla systemu <code class="language-plaintext highlighter-rouge">host</code> istnieje gotowy pakiet zawierający zestaw narzędzi do skrośnego budowania aplikacji (tzw. <code class="language-plaintext highlighter-rouge">toolchain</code>) oraz podstawowe biblioteki dla architektury docelowej</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre>apt list <span class="s2">"crossbuild*"</span>
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Jego instalacja umożliwia bezproblemową kompilację prostych aplikacji.
Problem koegzystencji został rozwiązany poprzez zastosowanie konwencji nazewniczej polegającej na poprzedzeniu każdego programu wchodzącego w skład toolchainu prefiksem opisującym platformę docelową w formacie (łącznik na końcu prefiksu jest jego integralną częścią)</p>

<pre><code class="language-txt">&lt;arch&gt;-&lt;os&gt;-&lt;lib&gt;-
</code></pre>

<pre><code class="language-txt">&lt;arch&gt;-&lt;vendor&gt;-&lt;os&gt;-&lt;lib&gt;-
</code></pre>

<p>Na przykład typowymi prefiksami dla architektury ARM64 są <code class="language-plaintext highlighter-rouge">aarch64-linux-gnu-</code> lub <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux-gnu-</code></p>

<h4 id="łączenie-statyczne">Łączenie statyczne</h4>

<p>Szansa, że wersje bibliotek zainstalowanych w ‘<code class="language-plaintext highlighter-rouge">crossbuild</code>’ pokrywają się z bibliotekami w środowisku uruchomiania, jest niewielka, zatem konieczne jest uwolnienie się od warunku 3, poprzez wymuszenie łączenia statycznego np.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="nv">PREFIX</span><span class="o">=</span>aarch64-linux-gnu- <span class="p">;</span> <span class="k">${</span><span class="nv">PREFIX</span><span class="k">}</span>gcc <span class="nt">-c</span> <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-o</span> main.o main.c <span class="p">;</span> <span class="k">${</span><span class="nv">PREFIX</span><span class="k">}</span>gcc <span class="nt">-static</span> main.o
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Kompilator i linker skrośny ‘wiedzą’, gdzie w systemie <code class="language-plaintext highlighter-rouge">host</code> zainstalowano pliki stosowne dla architektury docelowej, co znacznie upraszcza składnię komend niezbędnych do skutecznego zbudowania aplikacji.
Aplikacja zbudowana jak wyżej może być uruchomiona na dowolnym systemie zgodnym z architekturą zdefiniowaną w zmiennej <code class="language-plaintext highlighter-rouge">PREFIX</code>.
Jednak za prostotę płacimy cenę: po pierwsze, aplikacja jest stosunkowo duża i po drugie, uzupełnienie zależności o bibliotekę, której brak w pakiecie ‘crossbuild`’ wymaga ręcznej kompilacji skrośnej biblioteki i ujęcia jej `explicite* w wywołaniach kompilatora i linkera.</p>

<h4 id="łączenie-dynamiczne">Łączenie dynamiczne</h4>

<p>Budowanie skrośne wykorzystujące łączenie dynamiczne jest bardziej złożone, gdyż na systemie <code class="language-plaintext highlighter-rouge">host</code> muszą znajdować <code class="language-plaintext highlighter-rouge">te same</code> biblioteki dynamiczne/współdzielone co na systemie <code class="language-plaintext highlighter-rouge">target</code>.
Spełnienie punktu 3 implikuje również instalację plików nagłówkowych skojarzonych z tymi bibliotekami.
Katalog zawierający te elementy jest nazywany <code class="language-plaintext highlighter-rouge">sysroot</code>. Zarówno kompilator skrośny, jak i linker skrośny muszą być poinformowane o jego położeniu. Zawartość <code class="language-plaintext highlighter-rouge">sysroot</code> ekstrahuje się z głównego systemu plików systemu <code class="language-plaintext highlighter-rouge">target</code>.
Wymóg utrzymania synchronizmu wymusza aktualizację jego kopii na systemie <code class="language-plaintext highlighter-rouge">host</code> po zmianie firmware na urządzeniu <code class="language-plaintext highlighter-rouge">target</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre><span class="nv">PREFIX</span><span class="o">=</span>aarch64-linux-gnu- <span class="p">;</span> <span class="nv">SYS</span><span class="o">=</span>rootfs <span class="p">;</span><span class="k">${</span><span class="nv">PREFIX</span><span class="k">}</span>gcc <span class="nt">--sysroot</span> <span class="k">${</span><span class="nv">SYS</span><span class="k">}</span> <span class="nt">-c</span> <span class="nt">-g</span> <span class="nt">-Wall</span> <span class="nt">-o</span> main.o main.c <span class="p">;</span> <span class="k">${</span><span class="nv">PREFIX</span><span class="k">}</span>gcc <span class="nt">--sysroot</span> <span class="k">${</span><span class="nv">SYS</span><span class="k">}</span> main.o
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Wartość zmiennej <code class="language-plaintext highlighter-rouge">PREFIX</code> jest używana do rozmieszczania plików w drzewie katalogów na etapie przygotowywania <code class="language-plaintext highlighter-rouge">rootfs</code>.
Jednocześnie jest ona wykorzystywana przez kompilator skrośny do poszukiwania plików.
Zatem łączenie dynamiczne aby prefiks kompilatora był taki sam jak dla <code class="language-plaintext highlighter-rouge">rootfs</code>.</p>

<p><code class="language-plaintext highlighter-rouge">Spełnienie tego warunku jest konieczne do bezproblemowej kompilacji i łączenia w trybie dynamicznym</code></p>

<p>Inną, bardziej elegancką metodą zapewnienia widoczności plików z urządzenia <code class="language-plaintext highlighter-rouge">target</code> jest ich <a href="#udost%C4%99pnianie-g%C5%82%C3%B3wnego-systemu-plik%C3%B3w-poprzez-nfs">udostępnienie z wykorzystaniem protokołu NFS</a>.</p>

<p>Poniżej przedstawiono definicje zadań kompilacji statycznej i dynamicznej w <code class="language-plaintext highlighter-rouge">Visual Studio Code</code>.
Dla kompilacji dynamicznej przyjęto założenie, że system plików urządzenia <code class="language-plaintext highlighter-rouge">target</code> jest widoczny w katalogu ‘<code class="language-plaintext highlighter-rouge">rootfs/</code>’.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CrossBuild with static linkage"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make PREFIX=aarch64-linux-gnu- STATIC=-static"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task creates static application produced with cross compiler installed on host."</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CrossBuild with dynamic linkage"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make PREFIX=aarch64-linux-gnu- SYSROOT=rootfs/"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task creates dynamically linked application produced with cross compiler installed on host. Target's rootfs is visible in rootfs/ folder."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<h3 id="22-konteneryzacja-środowiska-kompilacji-skrośnej">2.2 Konteneryzacja środowiska kompilacji skrośnej</h3>

<p>Instalowanie w systemie <code class="language-plaintext highlighter-rouge">host</code> kilku środowisk skrośnych prowadzi do dość sporego zamieszania w organizacji plików, zwłaszcza jeżeli narzędzia te pochodzą z równych źródeł.
Atrakcyjną alternatywą jest zamknięcie tych środowisk w kontenerach <code class="language-plaintext highlighter-rouge">Docker</code>‘a.
Zaletą jest o wiele łatwiejsze zarządzanie i całkowity brak interferencji pomiędzy tak zorganizowanymi środowiskami.
W ramach projektu <a href="https://github.com/dockcross/dockcross/"><code class="language-plaintext highlighter-rouge">Dockcross</code></a> zamknięto w kontenerach narzędzia kompilacji na wiele platform docelowych.
Ich zawartość obejmuje narzędzia do budowania aplikacji oraz standardową bibliotekę C (zrealizowaną jako <code class="language-plaintext highlighter-rouge">GNU C</code>, <code class="language-plaintext highlighter-rouge">musl</code> lub <code class="language-plaintext highlighter-rouge">uClib</code>).
Korzystanie z kontenerów jest wyjątkowo proste: instalacja sprowadza się do jednej komendy, a budowanie aplikacji wymagaja kosmetycznego retuszu pliku <code class="language-plaintext highlighter-rouge">Makefile</code>.
Dostępne typy architektur można sprawdzić w repozytorium <code class="language-plaintext highlighter-rouge">GitHub</code> projektu <a href="https://github.com/dockcross/dockcross">https://github.com/dockcross/dockcross</a> lub na <a href="https://hub.docker.com/u/dockcross">https://hub.docker.com/</a>.</p>

<p>Instalację środowiska realizuje komenda</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre>docker run <span class="nt">--rm</span> dockcross/arch-name <span class="o">&gt;</span> ./dockcross
<span class="nb">chmod</span> +x ./dockcross
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>W jej wyniku na system <code class="language-plaintext highlighter-rouge">host</code> zostanie pobrany odpowiedni kontener, a w katalogu projektu utworzony skrypt <code class="language-plaintext highlighter-rouge">dockcross</code> umożliwiający korzystanie z jego zawartości.
Jeżeli kontener ma być używany również w innych projektach to skrypt należy przenieść do katalogu znajdującego się na ścieżce dostępu i zmienić jego nazwę na taką, która informuje o nazwie architektury. 
Parametry linii komend tego skryptu traktowane są jak linia poleceń, którą należy przekazać do kontenera.
Jednocześnie bieżący katalog jest mapowany do wnętrza kontenera, co powoduje, że pliki projektu są dostępne dla kompilatora w katalogu roboczym kontenera.
Na przykład, aby sprawdzić jak nazywa się kompilator umieszczony w kontenerze wystarczy wydać komendę</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre>./dockcross bash <span class="nt">-c</span> <span class="s1">'echo $CC'</span>
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Powyższa komenda pozwala na ustalenie wartości zmiennej <code class="language-plaintext highlighter-rouge">PREFIX</code> używanej we wcześniejszych przykładach.
Na przykład dla kontenera <code class="language-plaintext highlighter-rouge">dockcross/linux-arm64</code> przyjmie ona wartość <code class="language-plaintext highlighter-rouge">aarch64-unknown-linux-gnu-</code>.
W rezultacie komenda realizująca kompilację skrośną wymaga prostego uzupełnienia o wywołanie skryptu</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre>./dockcross bash <span class="nt">-c</span> <span class="s1">'PREFIX=aarch64-unknown-linux-gnu- ; ${PREFIX}gcc -c -g -Wall -o main.o main.c ; ${PREFIX}gcc -static main.o -o myapp'</span>
</pre></td>
</tr></tbody></table></code></pre></div></div>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Containerized CrossBuild with static linkage"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"./dockcross bash -c 'make PREFIX=aarch64-unknown-linux-gnu- STATIC=-static'"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task creates static application produced with cross compiler installed dockcross container (https://github.com/dockcross/dockcross)."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Niestety, z dużym prawdopodobieństwem kompilator zawarty w kontenerze będzie niekompatybilny z kompilatorem użytym do wytworzenia <code class="language-plaintext highlighter-rouge">rootfs</code>. W efekcie łączenie w trybie dynamicznym nie będzie możliwe.</p>

<h2 id="3-debugowanie-skrośne">3. Debugowanie skrośne</h2>

<p>Natywne debugowanie kodu z wykorzystaniem GUI pracującego na systemie <code class="language-plaintext highlighter-rouge">target</code> jest często awykonalne, głównie ze względu na ograniczony interfejs użytkownika i niezbyt duże zasoby urządzenia.
Z kolei zdalna praca w konsoli tekstowej z debuggerem <code class="language-plaintext highlighter-rouge">gdb</code> jest doznaniem ekstremalnym.</p>

<p>Rozwiązaniem problemu jest podzielenie zadania uruchamiania na dwa oddzielne procesy. Proces <code class="language-plaintext highlighter-rouge">gdbserver</code> pracuje na systemie <code class="language-plaintext highlighter-rouge">target</code> i odpowiada za krokowe wykonywanie uruchamianej aplikacji.
Z kolei interfejs użytkownika uruchomiony na systemie <code class="language-plaintext highlighter-rouge">host</code> komunikuje się z serwerem poprzez sieć lub łącze szeregowe (w dalszej części pojawią się konfiguracje dla łącza sieciowego).
Programem uruchomionym na systemie <code class="language-plaintext highlighter-rouge">host</code> jest <code class="language-plaintext highlighter-rouge">gdb-multiarch</code> (jest to wersja <code class="language-plaintext highlighter-rouge">gdb</code>, która “rozumie” różne architektury). Oba komponenty komunikują się za pomocą protokołu TCP/IP.
W efekcie struktura komunikacji pomiędzy narzędziami jest następująca: interfejs GUI uruchomiony w systemie <code class="language-plaintext highlighter-rouge">host</code> komunikuje się lokalnie z <code class="language-plaintext highlighter-rouge">gdb-multiarch</code>, który z kolei poprzez sieć komunikuje się z <code class="language-plaintext highlighter-rouge">gdbserver</code> uruchomionym na systemie <code class="language-plaintext highlighter-rouge">target</code>.
GUI odpowiedzialne za przeprowadzenie sesji uruchamiania musi poinformować <code class="language-plaintext highlighter-rouge">gdb-multiarch</code> o architekturze uruchamianego kodu i adresie serwera oczekującego na połączenie.
W <code class="language-plaintext highlighter-rouge">Visual Studio Code</code> za konfigurację procesu uruchamiania odpowiedzialny jest plik ‘<code class="language-plaintext highlighter-rouge">.vscode/launch.json</code>’.
Dla rozważanego projektu przyjmie on postać</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"GDB-REMOTE"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppdbg"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/main"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"miDebuggerServerAddress"</span><span class="p">:</span><span class="w"> </span><span class="s2">"opi.usb:1234"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"miDebuggerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/bin/gdb-multiarch"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"targetArchitecture"</span><span class="p">:</span><span class="w"> </span><span class="s2">"arm64"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nl">"stopAtEntry"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
      </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"environment"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nl">"externalConsole"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
      </span><span class="nl">"MIMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"setupCommands"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
          </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sets target architecture"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-ex 'set architecture aarch64'"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w">
          </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enable pretty-printing for gdb"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-enable-pretty-printing"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Sesję uruchamiania aktywuje się skrótem “<code class="language-plaintext highlighter-rouge">F5</code>” lub wybierając ikonę “żuczka” <img src="bug.png" alt="bug"> na pasku bocznym.
Powyższe zadanie realizuje tylko komunikację lokalną z <code class="language-plaintext highlighter-rouge">gdb-multiarch</code>, tak więc każdorazowo <code class="language-plaintext highlighter-rouge">przed rozpoczęciem sesji uruchamiania</code> należy w terminalu <code class="language-plaintext highlighter-rouge">Visual Studio Code</code> wydać komendę</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre>scp ./main root@opi.usb: <span class="o">&amp;&amp;</span> ssh <span class="nt">-t</span> root@opi.usb <span class="s2">"gdbserver --once localhost:1234 ./main"</span>
</pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Zadanie można sobie znacznie ułatwić, dopisując odpowiednie cele do ‘<code class="language-plaintext highlighter-rouge">Makefile</code>’</p>

<pre><code class="language-Makefile">debug: $(APPNAME)
  scp $(APPNAME) $(REMOTE): &amp;&amp; ssh -t $(REMOTE) "gdbserver --once localhost:1234 ./$(APPNAME)"

run: $(APPNAME)
  scp $(APPNAME) $(REMOTE): &amp;&amp; ssh -t $(REMOTE) "./$(APPNAME)"
</code></pre>

<h2 id="podsumowanie">Podsumowanie</h2>

<p>Kompilacja skrośna własnego kodu nastręcza wielu problemów.
Jeszcze więcej problemów pojawia się podczas kompilacji cudzych aplikacji.
Profesjonalnie napisane aplikacje są wyposażone w mechanizm budowy dostosowujący je do środowiska kompilacji.
Zazwyczaj budowanie aplikacji poprzedzonej jest uruchomieniem skryptu <code class="language-plaintext highlighter-rouge">./configure</code>wygenerowanym przez środowisko <code class="language-plaintext highlighter-rouge">automake</code>.
Zadaniem skryptu jest wykrycie dostępności pewnych składników systemie, ustawienie odpowiednich flag kompilacji i przygotowanie pliku <code class="language-plaintext highlighter-rouge">Makefile</code> dla programu <code class="language-plaintext highlighter-rouge">make</code>.
Schemat ten działa poprawnie gdy system na którym ma być wykonywania aplikacja jest identycznie skonfigurowany (w sensie dostępności wykrywanych składników) z systemem na którym wykonywana jest aplikacja.
W przypadku kompilacji skrośnej założenie to nie jest spełnione.
Skrypt <code class="language-plaintext highlighter-rouge">./configure</code> po prostu <code class="language-plaintext highlighter-rouge">odpytuje niewłaściwy system</code>.
W efekcie ustawione opcje kompilacji są niepoprawne, co skutkuje błędami kompilacji, lub co gorsza, wygenerowaniem niewłaściwie działającego kodu.
Ręczny dobór odpowiednich przełączników i adaptacja obcego kodu źródłowego jest zazwyczaj doznaniem ekstremalnym.</p>

<p><code class="language-plaintext highlighter-rouge">W zasadzie wszystkie opisane problemy można rozwiązać stosując [kompilację w trybie emulowanym](../../post/2023-08-13-emulated-building-for-sbc/).</code></p>

<h3 id="wady-i-zalety">Wady i zalety</h3>

<p>Budowanie natywne</p>

<table>
  <thead>
    <tr>
      <th>zalety</th>
      <th>wady</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>możliwość tworzenie kodu łączonego dynamicznie</td>
      <td>konieczność instalacji narzędzi deweloperskich na urządzeniu <code class="language-plaintext highlighter-rouge">target</code>
</td>
    </tr>
    <tr>
      <td> </td>
      <td>tworzenie kodu wymaga bezpośredniego dostepu do urządzenia docelowego</td>
    </tr>
  </tbody>
</table>

<p>Budowanie skrośne</p>

<table>
  <thead>
    <tr>
      <th>zalety</th>
      <th>wady</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kompilacja na urządzeniu host</td>
      <td>kod łączony dynamicznie może być przygotowany tylko w specyficznych sytuacjach</td>
    </tr>
    <tr>
      <td>możliwość hermetyzacji środowiska w kontenerze</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="przydatne-pliki-konfiguracyjne">Przydatne pliki konfiguracyjne</h3>

<p><code class="language-plaintext highlighter-rouge">Makefile</code> na wszystkie okazje</p>

<pre><code class="language-Makefile"># Compiler settings - Can be customized.
PREFIX=
STATIC=
CC = $(PREFIX)gcc
CXX =$(PREFIX)g++
CPPFLAGS =
CFLAGS = -std=c11 -g -Wall -fdiagnostics-color=always
CXXFLAGS = -std=c++11 -g -Wall -fdiagnostics-color=always
# LDFLAGS = $(STATIC) -lpthread -lgpiod 
LDFLAGS = $(STATIC) 

ifdef SYSROOT
    CFLAGS += --sysroot=$(SYSROOT)
    CXXFLAGS += --sysroot=$(SYSROOT)
    LDLAGS += --sysroot=$(SYSROOT)
endif

# Makefile settings - Can be customized.
APPNAME = main
EXT = .c
SRCDIR = src
OBJDIR = obj
REMOTE = root@opi.usb
REMOTEPWD = /root/RemotePowerButton

SRC = $(wildcard $(SRCDIR)/*$(EXT))
OBJ = $(SRC:$(SRCDIR)/%$(EXT)=$(OBJDIR)/%.o)
DEP = $(OBJ:$(OBJDIR)/%.o=%.d)

RM = rm -f

all: $(APPNAME)

# Copy sources to target
.PHONY: copysrc
copysrc:
  scp -p -r ./src/ ./obj/ ./Makefile $(REMOTE):$(REMOTEPWD)

.PHONY: debug
debug: $(APPNAME)
  scp $(APPNAME) $(REMOTE): &amp;&amp; ssh -t $(REMOTE) "gdbserver --once localhost:1234 ./$(APPNAME)"

.PHONY: run
run: $(APPNAME)
  scp $(APPNAME) $(REMOTE): &amp;&amp; ssh -t $(REMOTE) "./$(APPNAME)"

# Builds the app
$(APPNAME): $(OBJ)
  $(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

# Creates the dependecy rules
%.d: $(SRCDIR)/%$(EXT)
  @$(CPP) $(CFLAGS) $(CPPFLAGS) $&lt; -MM -MT $(@:%.d=$(OBJDIR)/%.o) &gt;$@

# Includes all .h files
-include $(DEP)

# Building rule for .o files and its .c/.cpp in combination with all .h
$(OBJDIR)/%.o: $(SRCDIR)/%$(EXT)
  $(CC) $(CFLAGS) $(CPPFLAGS) -o $@ -c $&lt;

# Cleans complete project
.PHONY: clean
clean:
  $(RM) $(OBJ) $(DEP) $(APPNAME)

# Cleans only all files with the extension .d
.PHONY: cleandep
cleandep:
  $(RM) $(DEP)
</code></pre>

<p>Wszystkie definicje zadań ``.vscode/tasks.json`’</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tasks"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CrossBuild with static linkage"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make PREFIX=aarch64-linux-gnu- STATIC=-static"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task creates static application produced with cross compiler installed on host."</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"CrossBuild with dynamic linkage"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make PREFIX=aarch64-linux-gnu- SYSROOT=/mnt/sysroot"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task creates dynamically linked application produced with cross compiler installed on host. Targets rootfs is visible in /mnt/sysroot."</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"label"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Build Natively on Target"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"command"</span><span class="p">:</span><span class="w"> </span><span class="s2">"make copysrc ; ssh root@opi.usb '(cd /root/RemotePowerButton; make)'"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"group"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">//</span><span class="nl">"isDefault"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"kind"</span><span class="p">:</span><span class="w"> </span><span class="s2">"build"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"options"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"problemMatcher"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
          </span><span class="s2">"$gcc"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"This task copies project sources to target and then it builds them natively there."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Konfiguracja <code class="language-plaintext highlighter-rouge">IntelliSense</code> w ‘<code class="language-plaintext highlighter-rouge">.vscode/c_cpp_properties.json</code>’</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"NativeOverSSH"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"includePath"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/src/``"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"${workspaceFolder}/rootfs/``"</span><span class="w">
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"defines"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">symbols</span><span class="w"> </span><span class="err">resolved</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">preprocessor</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="err">are</span><span class="w"> </span><span class="err">unknown</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">IntelliSense</span><span class="w">
                </span><span class="s2">"NULL=0"</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">I</span><span class="w"> </span><span class="err">suspect</span><span class="w"> </span><span class="err">that</span><span class="w"> </span><span class="s2">"#     define NULL 0"</span><span class="w"> </span><span class="err">in</span><span class="w"> </span><span class="err">types.h</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">accepted</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">cpp</span><span class="p">,</span><span class="w"> </span><span class="err">but</span><span class="w"> </span><span class="err">IGNORED</span><span class="w"> </span><span class="err">by</span><span class="w"> </span><span class="err">IntelliSense</span><span class="w"> 
            </span><span class="p">],</span><span class="w">
            </span><span class="nl">"compilerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cStandard"</span><span class="p">:</span><span class="w"> </span><span class="s2">"c11"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"cppStandard"</span><span class="p">:</span><span class="w"> </span><span class="s2">"c++11"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"intelliSenseMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"linux-gcc-arm64"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<p>Konfiguracja sesji uruchamiania w ‘<code class="language-plaintext highlighter-rouge">.vscode/launch.json</code>’</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td>
<td class="rouge-code"><pre><span class="p">{</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"configurations"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"GDB-REMOTE"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cppdbg"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"launch"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"program"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}/main"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"miDebuggerServerAddress"</span><span class="p">:</span><span class="w"> </span><span class="s2">"opi.usb:1234"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"miDebuggerPath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/bin/gdb-multiarch"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"targetArchitecture"</span><span class="p">:</span><span class="w"> </span><span class="s2">"arm64"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"args"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nl">"stopAtEntry"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
      </span><span class="nl">"cwd"</span><span class="p">:</span><span class="w"> </span><span class="s2">"${workspaceFolder}"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"environment"</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span><span class="w">
      </span><span class="nl">"externalConsole"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
      </span><span class="nl">"MIMode"</span><span class="p">:</span><span class="w"> </span><span class="s2">"gdb"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"setupCommands"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
          </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sets target architecture"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-ex 'set architecture aarch64'"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w">
          </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Enable pretty-printing for gdb"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"-enable-pretty-printing"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"ignoreFailures"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></td>
</tr></tbody></table></code></pre></div></div>

<h2 id="4-kruczki-i-sztuczki">4. Kruczki i sztuczki</h2>

<h3 id="41-zdalny-dostęp-do-konta-administratora-bez-podawania-hasła">4.1 Zdalny dostęp do konta administratora bez podawania hasła</h3>

<ol>
  <li>
    <p>Zdalny dostęp do konta administratora</p>

    <p>W pliku <code class="language-plaintext highlighter-rouge">/etc/ssh/sshd_config</code>’ (<code class="language-plaintext highlighter-rouge">target</code>) należy ustawić opcję</p>

    <pre><code class="language-txt"> PermitRootLogin   yes
</code></pre>
  </li>
  <li>
    <p>Logowanie bez konieczności podawania hasła</p>
    <ul>
      <li>
        <p>Serwer <code class="language-plaintext highlighter-rouge">SSH</code> musi zezwalać na uwierzytelnienie za pomocą kluczy publicznych.
W pliku <code class="language-plaintext highlighter-rouge">/etc/ssh/sshd_config</code>’ (<code class="language-plaintext highlighter-rouge">target</code>) należy ustawić opcje</p>

        <pre><code class="language-txt">PubkeyAuthentication   yes
AuthorizedKeysFile    .ssh/authorized_keys    .ssh/authorized_keys2
</code></pre>
      </li>
      <li>
        <p>Użytkownik systemu <code class="language-plaintext highlighter-rouge">host</code> musi mieć wygenerowane osobiste klucze <code class="language-plaintext highlighter-rouge">SSH</code>. Generacja komendą</p>

        <pre><code class="language-txt">ssh-keygen
</code></pre>

        <p>Opcją ‘-t’ można wymusić typ klucza, a opcją ‘-b’ jego długość. Wygenerowane klucze, prywatny i publiczny, umieszczone są w podkatalogu ‘.ssh’ katalogu domowego (publiczny ma rozszerzenie ‘pub’).</p>
      </li>
      <li>
        <p>Klucz publiczny należy umieścić na systemie <code class="language-plaintext highlighter-rouge">target</code> w pliku ‘<code class="language-plaintext highlighter-rouge">.ssh/authorized_keys</code>’ na
koncie docelowym. Wygodne kopiowanie zapewnia komenda (poniżej użyto konta <code class="language-plaintext highlighter-rouge">root</code>)</p>

        <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre>ssh-copy-id root@opi.usb
</pre></td>
</tr></tbody></table></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<!-- ### Pobranie głównego systemu plików z działającego urządzenia

Jeżeli główny system plików archiwizujemy z działającego urządzenia `target`, to przed operacją archiwizacji katalog główny należy zamontować w innym miejscu przy użyciu 'mount --bind' i dopiero w nim wydać komendę archiwizacji. Wynik archiwizacji najlepiej od razu pobrać na system `host`

```sh
ssh root@opi.usb 'mkdir -p /tmp/rootfs && mount --bind / /tmp/rootfs && cd /tmp/rootfs/ && tar cf - *' > rootfs.tar
```

W powyższej komendzie `opi.usb` to nazwa sieciowa urządzenia `target` i może być zastąpiona przez jego numer IP. -->

<h3 id="42-udostępnianie-głównego-systemu-plików-poprzez-nfs">4.2 Udostępnianie głównego systemu plików poprzez NFS</h3>

<h4 id="system-target">System <code class="language-plaintext highlighter-rouge">target</code>
</h4>

<ol>
  <li>
    <p>Instalacja serwera NFS.</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre> apt <span class="nb">install</span> <span class="nt">-y</span> nfs-kernel-server
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>Udostępnienie katalogu ‘/usr’ w trybie tylko do odczytu</p>

    <p>Zatrzymanie serwera</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre> systemctl stop nfs-kernel-server
</pre></td>
</tr></tbody></table></code></pre></div>    </div>

    <p>Aktualizacja ‘/etc/exports’</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre> /usr <span class="k">*</span><span class="o">(</span>ro,sync,no_subtree_check<span class="o">)</span>
</pre></td>
</tr></tbody></table></code></pre></div>    </div>

    <p>Uruchomienie serwera</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td>
<td class="rouge-code"><pre> exportsfs <span class="nt">-ra</span>
 systemctl start nfs-kernel-server
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
</ol>

<h4 id="system-host">System <code class="language-plaintext highlighter-rouge">host</code>
</h4>

<ol>
  <li>
    <p>Utworzenie punktu montowania</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre> <span class="nb">mkdir</span> <span class="nt">-p</span> /mnt/sysroot/usr
</pre></td>
</tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p>Montowanie zdalnego folderu na żądanie. W ‘/etc/fstab’</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre> opi.usb:/usr /mnt/sysroot/usr  nfs noauto,nofail,noatime,nolock  0 0
</pre></td>
</tr></tbody></table></code></pre></div>    </div>

    <p>Montowanie komendą</p>

    <div class="language-sh highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td>
<td class="rouge-code"><pre> <span class="nb">sudo </span>mount /mnt/sysroot/usr
</pre></td>
</tr></tbody></table></code></pre></div>    </div>

    <p>Kompilator należy poinformować, że katalogiem ‘<code class="language-plaintext highlighter-rouge">sysroot</code>’ jest ‘<code class="language-plaintext highlighter-rouge">/mnt/sysroot</code>’.</p>
  </li>
</ol>

<p>P.S. <code class="language-plaintext highlighter-rouge">Chętnie się dowiem jak prosto udostępnić "/" w którym są linki symboliczne np. </code>bin-&gt;/usr/bin``.</p>
</body></html>
