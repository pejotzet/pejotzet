[{"content":"W poradniku pokazano jak wykorzystać konteneryzację i wsparcie dla niej w Visual Studio Code do realizacji statycznego serwisu WWW. Opis obejmuje wykorzystanie kontenerów do stworzenia hermetycznego i przenośnego środowiska pracy oraz hosting lokalny i z użyciem GitHub. Przedstawiona metoda lokalnego hostingu umożliwia dostęp do serwisu za pomocą bezpiecznego protokołu HTTPS i umożliwia korzystanie z usług dynamicznego rozwiązywania nazw gdy adres IP zrealizowanego serwera jest zmienny.\nCzynności wstępne Praktyczna realizacja porad wymaga zainstalowania Git, Docker\u0026lsquo;a w wersji desktop lub serwer i Code oraz posiadania kont na GitHub i opcjonalnie DuckDNS.\nPrzygotowanie folderu projektu Utwórz puste repozytorium GitHub. Repozytorium będzie wykorzystywane do przechowywania plików generatora Hugo oraz plików źródłowych. Jeżeli konto GitHub ma być wykorzystywane również do publikacji gotowego serwisu oraz automatycznej generacji stron po aktualizacji zawartości serwisu, to powinno być ustawione jako publiczne. W kontach prywatnych funkcjonalności te są dostępne tylko za opłatą.\nSklonuj repozytorium do lokalnego folderu. Procedura klonowania zapewnia, że katalog projektu jest już w zasadzie zainicjowany jako repozytorium Git, tzn. istnieje podkatalog .git/ zawierający niezbędne metadane. W trakcie pracy nad serwisem zawartość katalogu projektu będzie podlegała zmianom. Utrzymanie synchronizmu z repozytorium GitHub wymaga nadążnej aktualizacji lokalnego folderu ze zmianami jakie zaszły w zdalnym repozytorium (git fetch) oraz okresowego wypychania zmian naniesionych lokalnie do zdalnego repozytorium (git stage, git commit, git push). Działania te będą wykonywane półautomatycznie przez VS Code. Jednak poprawne działanie klienta Git wymaga przypisania do lokalnego repozytorium pseudonimu i adresu email użytkownika, który nanosi w nim zmiany. Dlatego w katalogu projektu po jego utworzeniu należy wydać komendy\ngit config user.name \u0026quot;your_name\u0026quot; git config user.email \u0026quot;your_mail@somewhere.com\u0026quot; Zainstaluj kontener deweloperski zawierający gotowe środowisko pracy. Edytor Code umożliwia korzystanie z kontenerów Docker\u0026rsquo;a zawierających gotowe i hermetyczne środowiska pracy. Mechanizm ten nazwano DevContainers. Code po uruchomieniu w katalogu odpowiednio skonfigurowanego projektu \u0026ldquo;wchodzi\u0026rdquo; do wnętrza kontenera, a katalog projektu jest mapowany na katalog roboczy wewnątrz kontenera. Dla dewelopera automatycznie wszystkie narzędzia zainstalowane w kontenerze stają się dostępne. Jednocześnie wprowadzone przez niego zmiany ograniczone są do plików projektu oraz plików kontenera, przy czym te drugie są ulotne i znikają po skasowaniu kontenera. Tylko zmiany naniesione w katalogu roboczym mają charakter trwały. Dla wielu typów projektów szablony środowisk pracy są już przygotowane i publicznie udostępnione. W omawianym przypadku wykorzystamy środowisko do pracy ze statycznym generatorem stron o nazwie Hugo. Jest to jeden z najlepszych generatorów tego typu. W tym celu należy z podkatalogu containers/hugo repozytorium https://github.com/microsoft/vscode-dev-containers/ pobrać wraz zawartością katalog .devcontainer/ i opcjonalnie .vscode/. Zadanie to realizuje komenda\ncurl -Ls https://github.com/microsoft/vscode-dev-containers/archive/main.tar.gz | tar -xvz --strip-components=3 --wildcards '*/*/hugo/.*' Ze względu na niewielką liczbe importowanych plików zadanie to można wykonać \u0026ldquo;ręcznie\u0026rdquo; z użyciem przeglądarki WWW. Opisane wyżej zadania realizuje poniższy skrypt\n#!/bin/sh gh_user=your_gh_account gh_repo=your_gh_repo gh_name=your_name gh_mail=your_mail@somewhere.com git clone https://github.com/${gh_user}/${gh_repo} cd ${gh_repo} git config user.name \u0026quot;${gh_name}\u0026quot; git config user.email \u0026quot;${gh_mail}\u0026quot; curl -Ls https://github.com/microsoft/vscode-dev-containers/archive/main.tar.gz | tar -xvz --strip-components=3 --wildcards '*/*/hugo/.*' Przed pierwszym uruchomieniem warto zapoznać się z treścią plików .devcontainer/devcontainer.json i .devcontainer/Dockerfile, które definiują konfigurację kontenera i przepis na jego zbudowanie. Zmiany w pliku Dockerfile zazwyczaj nie są konieczne. Natomiast w devcontainer.json warto ustawić wersję Hugo na extended, wersję node na najwyższą wspieraną w Dockerfile, ustawić nazwę kontenera korzystając z runArgs, poprosić o wypisanie w terminalu wersji zainstalowanych narzędzi po utworzeniu kontenera, zmienić rozszerzenie wykorzystywane do obsługi plików TOML z bungcip.better-toml na tamasfe.even-better-toml, dołożyć sprawdzanie pisowni i opcjonalnie dodać rozszerzenie do parsowania plików definiujących GitHub Actions (więcej o tym później). Po wspomnianych modyfikacjach plik ten przyjmie postać\n{ \u0026quot;name\u0026quot;: \u0026quot;Hugo (Community)\u0026quot;, \u0026quot;build\u0026quot;: { \u0026quot;dockerfile\u0026quot;: \u0026quot;Dockerfile\u0026quot;, \u0026quot;args\u0026quot;: { \u0026quot;VARIANT\u0026quot;: \u0026quot;hugo_extended\u0026quot;, \u0026quot;VERSION\u0026quot;: \u0026quot;latest\u0026quot;, \u0026quot;NODE_VERSION\u0026quot;: \u0026quot;18\u0026quot; } }, \u0026quot;runArgs\u0026quot;: [\u0026quot;--name=this-is-Hugo-DevContainer\u0026quot;] , \u0026quot;customizations\u0026quot;: { \u0026quot;vscode\u0026quot;: { \u0026quot;settings\u0026quot;: { \u0026quot;html.format.templating\u0026quot;: true, \u0026quot;cSpell.language\u0026quot;: \u0026quot;en, pl\u0026quot;, \u0026quot;cSpell.userWords\u0026quot;: [\u0026quot;tutaj\u0026quot;, \u0026quot;wpisz\u0026quot;, \u0026quot;wyjątki\u0026quot;, \u0026quot;dla\u0026quot;, \u0026quot;słów\u0026quot;, \u0026quot;polskich\u0026quot;] }, \u0026quot;extensions\u0026quot;: [ \u0026quot;tamasfe.even-better-toml\u0026quot;, \u0026quot;davidanson.vscode-markdownlint\u0026quot;, \u0026quot;streetsidesoftware.code-spell-checker-polish\u0026quot;, \u0026quot;GitHub.vscode-github-actions\u0026quot; ]\t} }, \u0026quot;forwardPorts\u0026quot;: [ 1313 ], \u0026quot;postCreateCommand\u0026quot;: \u0026quot;uname -a \u0026amp;\u0026amp; hugo version \u0026amp;\u0026amp; node --version\u0026quot;, \u0026quot;remoteUser\u0026quot;: \u0026quot;node\u0026quot; } Teraz można uruchomić Code wydając w katalogu projektu komendę\ncode . Code \u0026ldquo;zauważy\u0026rdquo;, że istnieje podkatalog .devcontainer/ i zapyta, czy otworzyć projekt w kontenerze deweloperskim. Należy się na to zgodzić. Przełączenie pomiędzy pracą lokalną a kontenerem (traktowanym przez Code jak zdalna maszyna) aktywuje się za pomocą przycisku znajdującego się w lewym dolnym rogu interfejsu Code.\nPrzygotowanie szablonu serwisu Po uruchomieniu Code i wejściu do wnętrza kontenera (pierwsze uruchomienie nie jest natychmiastowe, gdyż kontener musi zostać zbudowany z komponentów pobieranych z sieci) należy uruchomić terminal (\u0026lsquo;Ctrl-Shift-`\u0026rsquo;) i zainicjować pusty serwis\nhugo new site . --force Praca z tak przygotowanym środowiskiem wymaga znacznego nakładu pracy i znajomości zasad generacji stron oraz przygotowanie szablonów HTML, które będą wypełniane treścią podczas generacji serwisu. Na szczęście można skorzystać z szablonów serwisów przygotowanych przez ochotników i udostępnionych na https://themes.gohugo.io/themes/. W dalszej części wykorzystamy szablon Fuji. Jego instalacja sprowadza się do wydania w katalogu projektu komendy\ngit submodule add https://github.com/dsrkafuu/hugo-theme-fuji.git themes/fuji Wszystkie prawidłowo przygotowane style serwisów zawierają gotowy przykład. Wystarczy go przenieść do budowanego serwisu, aby sprawdzić działanie przygotowanego środowiska pracy\ncp -r themes/fuji/exampleSite/* . Plik konfiguracyjny obecnej wersji Hugo nosi nazwę hugo.toml. Wiele szablonów korzysta ze starszej konwencji i opiera się o plik config.toml. Konfiguracją z szablonu należy nadpisać domyślny plik konfiguracyjny generatora stron\nmv config.toml hugo.toml Na obecnym etapie można już wygenerować serwis wydaną w terminalu komendą\nhugo serwer -D Tak uruchomiony generator będzie śledził zmiany w plikach wejściowych i \u0026ldquo;na bieżąco\u0026rdquo; generował zawartość serwisu gotową do publikacji. Znajduje się ona w podkatalogu public/. Po wydaniu komendy Code zaproponuje podgląd serwisu. Wprowadzone zmiany można wyświetlać w przeglądarce systemowej lub wbudowanej w Code.\nPrzełącznik -D powoduje, że również strony oznaczone jako draft będą brane pod uwagę podczas generacji zawartości serwisu.\nPrzygotowanie treści serwisu Zadaniem generatora Hugo jest przekształcenie zbioru plików wejściowych w formacie Markdown w gotowy serwis WWW. Translacja Markdown na HTML odbywa się zgodne z szablonami zdefiniowanymi w stylu serwisu. Hugo wymaga, aby pliki źródłowe były umieszczone w katalogu content/. Są one pogrupowane w zależności od typu informacji zamieszczonej w serwisie. Rodzaje publikowanych informacji są zdefiniowane w ramach stylu, natomiast prawie zawsze występuje typ post/ reprezentujący wpis blogu. Każdy plik wejściowy jest opatrzony metadanymi zawierającymi tytuł, datę utworzenia itp. Sposób formatowania tych metadanych zawierają pliki zaimportowane z przykładowego serwisu. W kontekście dalszej pracy istotna jest flaga draft\n--- ... draft: yes --- Pliki z tą flagą są wyłączane z zawartości serwisu przeznaczonego do publikacji. Zatem, aby uniknąć publikacji zaimportowanych przykładowych plików należy w każdym z nich ustawić tę flagę.\nKolejnym elementem, którego edycja jest niezbędna, jest plik hugo.toml. Należy w nim ustawić URL pod którym będzie dostępny serwis. Jeżeli wartość zmiennej baseURL jest ustawiona na\nbaseURL = \u0026quot;https://your_gh_account.github.io/gh_repo/\u0026quot; to podgląd generowanych na bieżąco stron będzie dostępny pod adresem http://localhost:1313/gh_repo. Plik konfiguracyjny zawiera również wiele innych zmiennych, których nazwy i warości silnie zależą od użytego stylu serwisu.\nOstatnim z obowiązkowych kroków jest przygotowanie nowego wpisu. Hugo umożliwia przygotowanie jego szablonu. W katalogu projektu (terminal Code) należy wydać komendę\nhugo new post/to-moj-pierwszy-wpis.md która utworzy w katalogu post/ plik Markdown o treści\n--- title: \u0026quot;To Moj Pierwszy Wpis\u0026quot; date: 2023-08-05T17:18:23Z draft: true --- Plik ten należy uzupełnić treścią. Przy formatowaniu wpisu (treść, metadane) najlepiej kierować się przykładami zawartymi w szablonie serwisu. W niektórych szablonach streszczenia nowych wpisów pojawiają się na stronie głównej serwisu. Streszczenie oddziela się od treści głównej umieszczając w pliku wejściowym Markdown znacznik read more.\nWięcej informacji nt. prawidłowego przygotowania plików dla generatora jest dostępnych na stronie projektu Hugo. Przykłady zawarte w użytym szablonie serwisu również mogą być pomocne.\nPraca ze zdalnym repozytorium Zdalne repozytorium GitHub może wykorzystać trojako: do synchronizacji katalogów roboczych na kilku różnych komputerach, do stworzenia kopii zapasowej projektu oraz do automatycznego generowania serwisu i jego publikacji. Ostatniemu zagadnieniu poświęcono osobną sekcję.\nPraca z repozytorium GitHub w Code nie nastręcza żadnych trudności bowiem w edytor wbudowano odpowiednie mechanizmy. Pliki, które zmieniono względem ostatniej synchronizacji ze zdalnym repozytorium są oznaczane literką \u0026ldquo;U\u0026rdquo;. Aby zsynchronizować się zdalnym repozytorium należy na panelu bocznym wybrać ikonę współdzielenia. Synchronizacja odbywa się w paczkach zwanych \u0026ldquo;Commit\u0026rdquo;. Każdy \u0026ldquo;Commit\u0026rdquo; jest opatrzony krótkim opisem, zatem mechanizm ten umożliwia aktualizację repozytorium w sposób zorientowany problemowo. Aby plik znalazł się w danej paczce \u0026ldquo;Commit\u0026rdquo;, musi najpierw zostać przeniesiony do poczekalni (tzw. stage). Po wybraniu ikony współdzielenia prezentowana jest lista zmienionych plików projektu. Z listy tej można wybrać pliki, które zostają wystawione do aktualizacji (stage). Następnie, w górnej linii panelu bocznego należy wpisać opis paczki, a następnie wybrać \u0026ldquo;Commit\u0026rdquo;. Paczek \u0026ldquo;Commit\u0026rdquo; można utworzyć kilka. Aktualizację ze zdalnym repozytorium realizuje wybranie przycisku \u0026ldquo;Sync\u0026rdquo;.\nGit umożliwia wyłączenie wybranych plików z mechanizmu synchronizacji. Są one określone w pliku .gitignore, przy czym dozwolone jest stosowanie standardowych masek powłoki w postaci znaków \u0026ldquo;?\u0026rdquo; i \u0026ldquo;*\u0026rdquo;. Typowa postać tego pliku dla repozytorium zawierające projekt statycznego serwisu Hugo ma postać\nresources/_gen/* themes/*/exampleSite/* .vscode/ public/* Katalog resources/ zawiera pliki pośrednie wykorzystane przez generator, natomiast katalog public/ pliki wynikowe. Jeżeli repozytorium GitHub ma być wykorzystane do publikacji gotowego serwisu wygenerowanego lokalnie, to oczywiście katalog public/ należy usunąć z pliku .gitignore.\nPublikacja serwisu Publikacja serwisu wymaga wykonania dwóch czynności: wygenerowania stron HTML oraz umieszczenia ich na dostępnym publicznie serwerze WWW. Dalej opisano dwa podejścia. Pierwsze wykorzystuje usługi serwisu GitHub. Serwis GitHub, podobnie do GitLab i kilku innych serwisów wspierających pracę grupową nad projektami, zawiera usługi ciągłej integracji zmian i dostarczania nowych wersji oprogramowania (CI/CD). W środowisku GitHub usługa ta nosi nazwę GitHub Actions. Za jej pomocą można uaktywnić automatyczną generację zawartości serwisu po każdorazowej aktualizacji repozytorium i udostępnić jego zawartość korzystając z mechanizmu GitHub Pages. Serwis będzie dostępny pod adresem\nhttps://your_gh_account.github.io/gh_repo/ Poza konfiguracją mechanizmu CI/CD żadna dodatkowa konfiguracja nie jest potrzebna. Usługi GitHub Actions i GitHub Pages są dostępne nieodpłatnie dla repozytoriów publicznych.\nDrugie z opisanych podejść opisuje działania niezbędne do realizacji własnego hostingu. Do jego realizacji potrzebna będzie maszyna z publicznym (routowalnym) adresem IP. Nie ma wymogu aby adres ten był stały. Maszyna musi mieć skonfigurowany dostęp za pomocą protokołu SSH. Do hostingu wykorzystane zostaną kontenery Docker, zatem również konieczna jest instalacja tego serwera na maszynie publikującej serwis WWW. Nic nie stoi na przeszkodzie, aby maszyna wykorzystana do publikacji była zrealizowana jako wirtualny host w chmurze. Serwis WWW musi mieć swoją nazwę, zatem należy wykupić domenę lub skorzystać z darmowych odmian dynamicznych serwisów DNS do skojarzenia nazwy serwisu z adresem IP maszyny udostępniającej serwis. W prezentowanym dalej przykładzie zostanie wykorzystana usługa DuckDNS.\nGitHub Pages i GitHub Actions Pierwotnie usługi GitHub Pages i GitHub Actions były realizowane za pomocą osobnych mechanizmów. Obecnie GitHub Pages jest realizowane za pomocą wyspecjalizowanych akcji z usługi GitHub Actions. Innymi słowy, publikacja stron WWW to obecnie jedna z automatycznych akcji jakie mogą być podjęte po zmianie zawartości repozytorium.\nSerwis generowany lokalnie, publikacja statycznych stron W najprostszym przypadku jesteśmy zainteresowani tylko publikacją gotowych stron wygenerowanych lokalnie w środowisku Code i umieszczonych w ramach synchronizacji w repozytorium GitHub. Hugo generuje pliki wyjściowe w katalogu public, zatem tylko te pliki powinny zostać przeniesione do serwisu GitHub Pages.\nKonfigurowanie mechanizmu publikacji należy rozpocząć od skonfigurowania GitHub Pages.\nPo pierwsze w repozytorium musi w repozytorium istnieć gałąź Git o nazwie gh-pages. Można ją utworzyć w serwisie GitHub wybierając na stronie głównej repozytorium przycisk Branches. Alternatywnie można wykorzystać Code. Po wybraniu ikony synchronizacji wybieramy ... przy nazwie repozytorium , a następnie Branch-\u0026gt; Create Branch i wpisujemy gh-pages. Teraz utworzoną gałąź publikujemy (...-\u0026gt;Branch-\u0026gt;Publish Branch), co zapewni, że zostanie ona przeniesiona do drzewa Git znajdującego się w repozytorium GitHub.\nFunkcjonalność publikacji zawartości repozytorium należy również aktywować w jego ustawieniach. Należy otworzyć stronę\nhttps://github.com/${gh_user}/${gh_repo}/settings/pages i jako sposób publikacji (Build and deployment) należy wybrać GitHub Actions oraz opcję Static HTML. W repozytorium zostanie utworzony plik\n.github/workflows/static.yml Domyślnie akcja publikacji dotyczy zawartości całego repozytorium. Generator umieszcza pliki wynikowe w podkatalogu public/, zatem należy zaktualizować zmienną path w pliku konfiguracyjnym akcji static.yml\nname: Deploy static content to Pages on: push: branches: [\u0026quot;main\u0026quot;] workflow_dispatch: permissions: contents: read pages: write id-token: write concurrency: group: \u0026quot;pages\u0026quot; cancel-in-progress: false jobs: deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 - name: Setup Pages uses: actions/configure-pages@v3 - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: # Upload only 'public/' folder path: 'public/' - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v2 Serwisu generowany zdalnie i automatycznie publikowany Serwis GitHub umożliwia wykonywanie zautomatyzowanych działań na plikach repozytorium gdy nastąpi jakieś zdarzenie. Jednym ze zdarzeń, które mogą aktywować działanie jest zmiana zawartości repozytorium. Do realizacji automatycznych działań wykorzystywane są kontenery Dockera uruchamiane w chmurze. Wiele typowych akcji jest już skonfigurowanych i wystarczy tylko się do nich odwołać w konfiguracji repozytorium. Możliwa jest zatem konfiguracja, w której aktualizacja plików wejściowych generatora Hugo spowoduje zbudowanie serwisu WWW przy użyciu kontenera zawierającego generator, a następnie publikacja wyniku jego działania przy użyciu metody opisanej w poprzednim punkcie. Ponownie w Pages wybrać GitHub Actions należy jako metodę publikacji serwisu. Jednak tym razem należy wybrać zaproponowany wzorzec działania Hugo (Zmiana metody publikacji serwisu wymaga wcześniejszego wyłączenia.)\nname: Deploy Hugo site to Pages on: push: branches: [\u0026quot;main\u0026quot;] workflow_dispatch: permissions: contents: read pages: write id-token: write concurrency: group: \u0026quot;pages\u0026quot; cancel-in-progress: false defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.114.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v3 with: submodules: recursive - name: Setup Pages id: pages uses: actions/configure-pages@v3 - name: Install Node.js dependencies run: \u0026quot;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026quot; - name: Build with Hugo env: # For maximum backward compatibility with Hugo modules HUGO_ENVIRONMENT: production HUGO_ENV: production run: | hugo \\ --minify \\ --baseURL \u0026quot;${{ steps.pages.outputs.base_url }}/\u0026quot; - name: Upload artifact uses: actions/upload-pages-artifact@v2 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v2 Biorąc pod uwagę, że skonfigurowana akcja zapewnia generację plików HTML, to nie jest już konieczna synchronizacja plików z podkatalogu public. W przyjętej konfiguracji każdorazowa zmiana zawartości gałęzi main w repozytorium spowoduje wygenerowanie nowej wersji serwisu. Status wykonanych działań można śledzić na stronie\nhttps://github.com/your_gh_account/gh_repo/actions Wygenerowany serwis jest dostepny pod adresem\nhttps://your_gh_account.github.io/gh_repo/ Własny hosting serwisu Do realizacji lokalnego hostingu jakiekolwiek serwisu niezbędny jest routowalny (publiczny) adres IP. W omawianej konfiguracji przyjęto założenie, że adres ten jest przypisany do routera z usługą NAT, natomiast host realizujący serwis znajduje się w sieci lokalnej \u0026ldquo;schowanej\u0026rdquo; za routerem i korzystającej nieroutowalnych (prywatnych) adresów IP. Przyjęto również założenie, że host, na którym rozwijany jest serwis i na którym zainstalowano Code, znajduje się w tej samej sieci co host z serwisem WWW. Na hoście z serwisem WWW działa serwer SSH.\nDo publicznego adresu IP musi być przypisana kwalifikowana domenowa nazwa hosta (FQDN) w formacie nazwa.serwisu.moja.domena.org. Jeżeli adres IP jest stały, to wystarczy wykupić dla niego domenę. Dla adresów zmiennych konieczne jest skorzystanie z usługi dynamicznego DNS. Idea działania takiej usługi polega na tym, że host o zmiennym adresie IP otrzymuje identyfikator unikalny w ramach dynamicznego serwisu DNS i co pewien czas \u0026ldquo;melduje\u0026rdquo; swój adres IP. Usługa dynamicznego DNS rozpowszechnia tę informację, komunikując się z innymi serwisami DNS, które aktualizują swoją konfigurację. Oczywiście, dla stałych adresów IP skorzystanie z usługi dynamicznego DNS do uzyskania nazwy domenowej jest również możliwe. Darmowe usługi dynamicznego DNS pozwalają zazwyczaj tylko na określenie nazwy hosta, a domenowa część nazwy jest zadana przez dostawcę serwisu.\nZaproponowana konfiguracja hosta realizującego serwis pozwala na prowadzenie wielu serwisów WWW na tym samym adresie IP, jednak o różnych nazwach domenowych. Oczywiście nic nie stoi na przeszkodzie, aby do tego samego numeru IP przypisać wiele nazw domenowych. Dalej do skojarzenia adresu IP z nazwą domenową wykorzystany darmowy serwis https://duckdns.org. W serwisie należy założyć konto. W ramach każdego konta można nieodpłatnie założyć kilka domen (wraz z subdomenami). Każdy użytkownik serwisu ma przypisany unikalny token, który jest wykorzystywany do aktualizacji zmiennego adresu IP.\nNa hoście, który ma utrzymywać serwis www konieczna jest instalacja serwera Dockera. Użytkownik zdalnego hosta powinien być dodany do grupy docker, co uwolnia od konieczności pracy z Dockerem na prawach administratora.\nsudo usermod -aG docker ${USER} Aby powyższa zmiana odniosła skutek, należy się wylogować i zalogować lub w otwartych sesjach wydać komendę\nnewgrp docker W zdalnym zarządzaniu kontenerami dobrze spisuje się Portainer. Uboższa jego wersja jest dostępna nieodpłatnie. Instalacja sprowadza się do dwóch komend\ndocker volume create portainer_data docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest Od teraz zainstalowanymi obrazami i kontenerami można zarządzać łącząc się przeglądarką przy użyciu protokołu HTTP z portem 9000 hosta z Portainerem.\nInstalacja własnego serwisu WWW jest bardzo prosta. Do katalogu services hosta\nmkdir -p /home/your_host_account/services/ cd /home/your_host_account/services/ wgrywamy plik docker-compose.yml o następującej treści\nversion: \u0026quot;3\u0026quot; networks: frontend: name: dmz services: duckdns: image: lscr.io/linuxserver/duckdns:latest container_name: dmz-duckdns environment: - PUID=1000 #optional - PGID=1000 #optional - TZ=Europe/Warsaw - SUBDOMAINS=zawadzki,zawadzka - TOKEN=xxxxxxxx-yyyy-zzzz-aaaa-bbbbbbbbbbbb - LOG_FILE=true #optional volumes: - /home/your_host_account/services/duckdns:/config #optional networks: - frontend restart: unless-stopped nginxproxy: image: 'jc21/nginx-proxy-manager:latest' container_name: dmz-nginxproxy restart: unless-stopped ports: - '8888:80' - '81:81' - '4443:443' volumes: - /home/your_host_account/services/npm/data:/data - /home/your_host_account/services/npm/letsencrypt:/etc/letsencrypt networks: - frontend www0: image: lscr.io/linuxserver/nginx:latest container_name: dmz-www0 environment: - PUID=1000 - PGID=1000 - TZ=Europe/London volumes: - /home/your_host_account/services/www0:/config restart: unless-stopped networks: - frontend www1: image: lscr.io/linuxserver/nginx:latest container_name: dmz-www1 environment: - PUID=1000 - PGID=1000 - TZ=Europe/London volumes: - /home/your_host_account/services/www1:/config restart: unless-stopped networks: - frontend Następnie należy utworzyć puste katalogi, w których będą przechowywane dane z kontenerów\nmkdir -p {duckdns,npm/data,npm/letsencrypt,www0,www1} Ostateczne uruchomienie stosu usług realizuje komenda\ndocker compose up -d wydana w katalogu z plikiem docker-compose.yml.\nKontener duckdns odpowiada za aktualizację adresu IP serwisu w usłudze dynamicznego DNS. Kontener nginx-proxy-manager realizuje reverse-proxy, za którym schowane są serwisy www0 i www1. Kontener ten również troszczy się o utrzymanie aktualnego certyfikatu dla domen skonfigurowanych w ramach proxy. Zarządzanie proxy (i domenami) realizuje się za pomocą interfejsu WWW dostępnego na porcie 81. Interfejsy http i https zarządzanych usług dostępne są odpowiednio na portach 8888 i 4443 dlatego na routerze realizującym NAT należy uaktywnić Port Forwarding i zrealizować przypisanie \u0026ldquo;80-\u0026gt;ip_host:8888\u0026rdquo;, \u0026ldquo;443-\u0026gt;ip_host:4443\u0026rdquo;. W ten sposób ruch docierający do routera i skojarzony z protokołami http i https zostanie przekierowany do usługi proxy, a ta, na podstawie nazwy domenowej, podejmie decyzję do którego serwisu WWW ruch powinien być skierowany. Wspomniane przekierowanie portów musi być wykonane przed konfiguracją proxy, bowiem są one wykorzystywane do komunikacji z serwisem LetsEncrypt w celu uzyskania certyfikatów SSL.\nKonfiguracja Nginx Proxy Manager jest stosunkowo prosta. Pierwsze łączenie z interfejsem administracyjnym (port 81) wymaga zmiany hasła i nazwy użytkownika (domyślnymi wartościami są admin i changeme). Konfigurację rozpoczynamy od uzyskania certyfikatów dla skonfigurowanych domen (Dashboard-\u0026gt;SSL Certificates). Następnie dodajemy Proxy Hosts. Jako nazwę Forward Hostname należy podać nazwę kontenera,czyli w rozważanym przypadku dmz-www0 lub dmz-www1.\nŚrodowisko do prezentacji zawartości serwisu jest już przygotowane. Należy jedynie pamiętać, aby w konfiguracji Hugo (config.toml) również ustawić nazwę skonfigurowaną w DuckDNS. Serwis generuje się jak zwykle, zatrzymując serwer i wydając w katalogu projektu komendę\nhugo Wystarczy teraz przesłać zawartość katalogu public/ do katalogu głównego serwera WWW tj.\nscp -r public/* user@ip_host_lan:/home/your_host_account/services/www1/www/ i serwis jest opublikowany.\nPodsumowanie","date":"2023-08-05","permalink":"https://mikroprofesor.duckdns.org/post/static-site-in-hugo/","tags":["Code","DevContainer","Hugo","Github Actions"],"title":"Jak założyć i utrzymywać statyczny serwis WWW wykorzystując Docker'a i Code"}]