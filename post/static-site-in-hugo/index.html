<!DOCTYPE html>
<html lang="pl">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.116.1">



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/cdn-stcapi@1/favicons/favicon.ico" />
<meta name="theme-color" content="#ffffff" />


<title>Jak założyć i utrzymywać statyczny serwis WWW wykorzystując Docker&#39;a i Code - Net i Dev Blog</title>


<meta name="author" content="Piotr Zawadzki" />


<meta name="description" content="Opis obejmuje czynności związane z założeniem projektu, przygotowaniem środowiska i tworzeniem treści połączonym z aktualizacją opublikowanych treści." />


<meta name="keywords" content="Code, DevContainer, Hugo, Github Actions" />


<meta property="og:title" content="Jak założyć i utrzymywać statyczny serwis WWW wykorzystując Docker&#39;a i Code" />
<meta name="twitter:title" content="Jak założyć i utrzymywać statyczny serwis WWW wykorzystując Docker&#39;a i Code" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://pejotzet.github.io/pejotzet/post/static-site-in-hugo/" /><meta property="og:description" content="Opis obejmuje czynności związane z założeniem projektu, przygotowaniem środowiska i tworzeniem treści połączonym z aktualizacją opublikowanych treści." />
<meta name="twitter:description" content="Opis obejmuje czynności związane z założeniem projektu, przygotowaniem środowiska i tworzeniem treści połączonym z aktualizacją opublikowanych treści." /><meta property="og:image" content="https://pejotzet.github.io/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://pejotzet.github.io/img/og.png" /><meta property="article:published_time" content="2023-08-05T10:06:43+00:00" /><meta property="article:modified_time" content="2023-08-05T10:06:43+00:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://pejotzet.github.io/pejotzet/assets/css/fuji.min.70d4d1242d0bccb3e2a2c0d666c76f4f231226d76c69aaaee6d49290b2680a2721c55bbbe447c365d0b29cb17422cb9df304de304b4d93765ecf8bd63fa1c2cc.css" integrity="sha512-cNTRJC0LzLPiosDWZsdvTyMSJtdsaaqu5tSSkLJoCichxVu75EfDZdCynLF0Isud8wTeMEtNk3Zez4vWP6HCzA==" />








</head>

<body
  data-theme="auto"
  data-theme-auto='true'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://pejotzet.github.io/pejotzet">Net i Dev Blog</a>
            
            <span class="title-sub">Zapiski ku pamięci i na pożytek</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://pejotzet.github.io/pejotzet/post/static-site-in-hugo/">Jak założyć i utrzymywać statyczny serwis WWW wykorzystując Docker&#39;a i Code</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2023-08-05</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3106 słowa</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/pejotzet/tags/code">Code</a>&nbsp;<a href="/pejotzet/tags/devcontainer">DevContainer</a>&nbsp;<a href="/pejotzet/tags/hugo">Hugo</a>&nbsp;<a href="/pejotzet/tags/github-actions">Github Actions</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <p>W poradniku pokazano jak wykorzystać konteneryzację i wsparcie dla niej w <code>Visual Studio Code</code> do realizacji statycznego serwisu WWW.
Opis obejmuje wykorzystanie kontenerów do stworzenia hermetycznego i przenośnego środowiska pracy
oraz hosting lokalny i z użyciem <code>GitHub</code>.
Przedstawiona metoda lokalnego hostingu umożliwia dostęp do serwisu za pomocą bezpiecznego protokołu <code>HTTPS</code> i umożliwia korzystanie z usług dynamicznego rozwiązywania nazw gdy adres <code>IP</code> zrealizowanego serwera jest zmienny.</p>
<h2 id="czynności-wstępne">Czynności wstępne</h2>
<p>Praktyczna realizacja porad wymaga zainstalowania <a href="https://git-scm.com/" target="_blank">Git</a>, <a href="https://www.docker.com/" target="_blank">Docker</a>&lsquo;a w wersji desktop lub serwer i <a href="https://code.visualstudio.com/" target="_blank">Code</a> oraz posiadania kont na <a href="https://github.com" target="_blank"><code>GitHub</code></a> i opcjonalnie <a href="https://ducnkdns.org" target="_blank"><code>DuckDNS</code></a>.</p>
<h3 id="przygotowanie-folderu-projektu">Przygotowanie folderu projektu</h3>
<ol>
<li>Utwórz puste repozytorium <a href="https://github.com" target="_blank">GitHub</a>.</li>
</ol>
<p>Repozytorium będzie wykorzystywane do przechowywania plików generatora <a href="https://gohugo.io/" target="_blank"><code>Hugo</code></a> oraz plików źródłowych.
Jeżeli konto <a href="https://github.com" target="_blank">GitHub</a> ma być wykorzystywane również do publikacji gotowego serwisu oraz automatycznej generacji stron po aktualizacji zawartości serwisu, to powinno być ustawione jako <em>publiczne</em>.
W kontach <em>prywatnych</em> funkcjonalności te są dostępne tylko za opłatą.</p>
<ol start="2">
<li>Sklonuj repozytorium do lokalnego folderu.</li>
</ol>
<p>Procedura klonowania zapewnia, że katalog projektu jest już w zasadzie zainicjowany jako repozytorium <code>Git</code>, tzn. istnieje podkatalog <code>.git/</code> zawierający niezbędne metadane.
W trakcie pracy nad serwisem zawartość katalogu projektu będzie podlegała zmianom.
Utrzymanie synchronizmu z repozytorium GitHub wymaga nadążnej aktualizacji lokalnego folderu ze zmianami jakie zaszły w zdalnym repozytorium (<code>git fetch</code>) oraz okresowego wypychania zmian naniesionych lokalnie do zdalnego repozytorium (<code>git stage</code>, <code>git commit</code>, <code>git push</code>).
Działania te będą wykonywane półautomatycznie przez <code>VS Code</code>.
Jednak poprawne działanie klienta <code>Git</code> wymaga przypisania do lokalnego repozytorium pseudonimu i adresu email użytkownika, który nanosi w nim zmiany.
Dlatego w katalogu projektu po jego utworzeniu należy wydać komendy</p>
<pre><code class="language-sh">git config user.name &quot;your_name&quot;
git config user.email &quot;your_mail@somewhere.com&quot;
</code></pre>
<ol start="3">
<li>Zainstaluj kontener deweloperski zawierający gotowe środowisko pracy.</li>
</ol>
<p>Edytor <code>Code</code> umożliwia korzystanie z kontenerów Docker&rsquo;a zawierających gotowe i hermetyczne środowiska pracy.
Mechanizm ten nazwano <code>DevContainers</code>.
<code>Code</code> po uruchomieniu w katalogu odpowiednio skonfigurowanego projektu &ldquo;wchodzi&rdquo; do wnętrza kontenera, a katalog projektu jest mapowany na katalog roboczy wewnątrz kontenera.
Dla dewelopera automatycznie wszystkie narzędzia zainstalowane w kontenerze stają się dostępne.
Jednocześnie wprowadzone przez niego zmiany ograniczone są do plików projektu oraz plików kontenera, przy czym te drugie są ulotne i znikają po skasowaniu kontenera.
Tylko zmiany naniesione w katalogu roboczym mają charakter trwały.
Dla wielu typów projektów szablony środowisk pracy są już przygotowane i <a href="https://github.com/microsoft/vscode-dev-containers/" target="_blank">publicznie udostępnione</a>.
W omawianym przypadku wykorzystamy środowisko do pracy ze statycznym generatorem stron o nazwie <code>Hugo</code>.
Jest to jeden z najlepszych generatorów tego typu.
W tym celu należy z podkatalogu <code>containers/hugo</code> repozytorium <a href="https://github.com/microsoft/vscode-dev-containers/" target="_blank">https://github.com/microsoft/vscode-dev-containers/</a> pobrać wraz zawartością katalog <code>.devcontainer/</code> i opcjonalnie <code>.vscode/</code>.
Zadanie to realizuje komenda</p>
<pre><code class="language-sh">curl -Ls https://github.com/microsoft/vscode-dev-containers/archive/main.tar.gz | tar -xvz --strip-components=3 --wildcards '*/*/hugo/.*'
</code></pre>
<p>Ze względu na niewielką liczbe importowanych plików zadanie to można wykonać &ldquo;ręcznie&rdquo; z użyciem przeglądarki WWW.
Opisane wyżej zadania realizuje poniższy skrypt</p>
<pre><code class="language-sh">#!/bin/sh
gh_user=your_gh_account
gh_repo=your_gh_repo
gh_name=your_name
gh_mail=your_mail@somewhere.com

git clone https://github.com/${gh_user}/${gh_repo}

cd ${gh_repo}
git config user.name &quot;${gh_name}&quot;
git config user.email &quot;${gh_mail}&quot;

curl -Ls https://github.com/microsoft/vscode-dev-containers/archive/main.tar.gz | tar -xvz --strip-components=3 --wildcards '*/*/hugo/.*'
</code></pre>
<p>Przed pierwszym uruchomieniem warto zapoznać się z treścią plików <code>.devcontainer/devcontainer.json</code> i <code>.devcontainer/Dockerfile</code>, które definiują konfigurację kontenera i przepis na jego zbudowanie.
Zmiany w pliku <code>Dockerfile</code> zazwyczaj nie są konieczne.
Natomiast w <code>devcontainer.json</code> warto ustawić wersję Hugo na <code>extended</code>, wersję <code>node</code> na najwyższą wspieraną w <code>Dockerfile</code>, ustawić nazwę kontenera korzystając z <code>runArgs</code>, poprosić o wypisanie w terminalu wersji zainstalowanych narzędzi po utworzeniu kontenera, zmienić rozszerzenie wykorzystywane do obsługi plików TOML z <code>bungcip.better-toml</code> na <code>tamasfe.even-better-toml</code>, dołożyć sprawdzanie pisowni i opcjonalnie dodać rozszerzenie do parsowania plików definiujących <code>GitHub Actions</code> (więcej o tym później).
Po wspomnianych modyfikacjach plik ten przyjmie postać</p>
<pre><code class="language-json">{
	&quot;name&quot;: &quot;Hugo (Community)&quot;,
	&quot;build&quot;: {
		&quot;dockerfile&quot;: &quot;Dockerfile&quot;,
		&quot;args&quot;: {
			&quot;VARIANT&quot;: &quot;hugo_extended&quot;,
			&quot;VERSION&quot;: &quot;latest&quot;,
			&quot;NODE_VERSION&quot;: &quot;18&quot;
		}
	},
	&quot;runArgs&quot;: [&quot;--name=this-is-Hugo-DevContainer&quot;] ,
	&quot;customizations&quot;: {
		&quot;vscode&quot;: {
			&quot;settings&quot;: { 
				&quot;html.format.templating&quot;: true,
				&quot;cSpell.language&quot;: &quot;en, pl&quot;,
				&quot;cSpell.userWords&quot;: [&quot;tutaj&quot;, &quot;wpisz&quot;, &quot;wyjątki&quot;, &quot;dla&quot;, &quot;słów&quot;, &quot;polskich&quot;]
						},
			&quot;extensions&quot;: [
				&quot;tamasfe.even-better-toml&quot;,
				&quot;davidanson.vscode-markdownlint&quot;,
				&quot;streetsidesoftware.code-spell-checker-polish&quot;,
				&quot;GitHub.vscode-github-actions&quot;
			]			  
		}
	},
	&quot;forwardPorts&quot;: [
		1313
	],
	&quot;postCreateCommand&quot;: &quot;uname -a &amp;&amp; hugo version &amp;&amp; node --version&quot;,
	&quot;remoteUser&quot;: &quot;node&quot;
}
</code></pre>
<p>Teraz można uruchomić <code>Code</code> wydając w katalogu projektu komendę</p>
<pre><code class="language-sh">code .
</code></pre>
<p><code>Code</code> &ldquo;zauważy&rdquo;, że istnieje podkatalog <code>.devcontainer/</code> i zapyta, czy otworzyć projekt w kontenerze deweloperskim.
Należy się na to zgodzić.
Przełączenie pomiędzy pracą lokalną a kontenerem (traktowanym przez <code>Code</code> jak zdalna maszyna) aktywuje się za pomocą przycisku znajdującego się w lewym dolnym rogu interfejsu <code>Code</code>.</p>
<h3 id="przygotowanie-szablonu-serwisu">Przygotowanie szablonu serwisu</h3>
<p>Po uruchomieniu <code>Code</code> i wejściu do wnętrza kontenera (<em>pierwsze uruchomienie nie jest natychmiastowe, gdyż kontener musi zostać zbudowany z komponentów pobieranych z sieci</em>) należy uruchomić terminal (&lsquo;Ctrl-Shift-`&rsquo;) i zainicjować pusty serwis</p>
<pre><code class="language-sh">hugo new site . --force
</code></pre>
<p>Praca z tak przygotowanym środowiskiem wymaga znacznego nakładu pracy i znajomości zasad generacji stron oraz przygotowanie szablonów HTML, które będą wypełniane treścią podczas generacji serwisu.
Na szczęście można skorzystać z szablonów serwisów przygotowanych przez ochotników i udostępnionych na <a href="https://themes.gohugo.io/themes/" target="_blank">https://themes.gohugo.io/themes/</a>.
W dalszej części wykorzystamy szablon <a href="https://themes.gohugo.io/themes/hugo-theme-fuji/" target="_blank">Fuji</a>.
Jego instalacja sprowadza się do wydania w katalogu projektu komendy</p>
<pre><code class="language-sh">git submodule add https://github.com/dsrkafuu/hugo-theme-fuji.git themes/fuji
</code></pre>
<p>Wszystkie prawidłowo przygotowane style serwisów zawierają gotowy przykład.
Wystarczy go przenieść do budowanego serwisu, aby sprawdzić działanie przygotowanego środowiska pracy</p>
<pre><code class="language-sh">cp -r themes/fuji/exampleSite/* .
</code></pre>
<p>Plik konfiguracyjny obecnej wersji <code>Hugo</code> nosi nazwę <code>hugo.toml</code>.
Wiele szablonów korzysta ze starszej konwencji i opiera się o plik <code>config.toml</code>.
Konfiguracją z szablonu należy nadpisać domyślny plik konfiguracyjny generatora stron</p>
<pre><code class="language-sh">mv config.toml hugo.toml
</code></pre>
<p>Na obecnym etapie można już wygenerować serwis wydaną w terminalu komendą</p>
<pre><code class="language-sh">hugo serwer -D
</code></pre>
<p>Tak uruchomiony generator będzie śledził zmiany w plikach wejściowych i &ldquo;na bieżąco&rdquo; generował zawartość serwisu gotową do publikacji.
Znajduje się ona w podkatalogu <code>public/</code>.
Po wydaniu komendy <code>Code</code> zaproponuje podgląd serwisu.
Wprowadzone zmiany można wyświetlać w przeglądarce systemowej lub wbudowanej w <code>Code</code>.</p>
<p>Przełącznik <code>-D</code> powoduje, że również strony oznaczone jako <code>draft</code> będą brane pod uwagę podczas generacji zawartości serwisu.</p>
<h2 id="przygotowanie-treści-serwisu">Przygotowanie treści serwisu</h2>
<p>Zadaniem generatora <code>Hugo</code> jest przekształcenie zbioru plików wejściowych w formacie <code>Markdown</code> w gotowy serwis WWW.
Translacja <code>Markdown</code> na HTML odbywa się zgodne z szablonami zdefiniowanymi w stylu serwisu.
<code>Hugo</code> wymaga, aby pliki źródłowe były umieszczone w katalogu <code>content/</code>.
Są one pogrupowane w zależności od typu informacji zamieszczonej w serwisie.
Rodzaje publikowanych informacji są zdefiniowane w ramach stylu, natomiast prawie zawsze występuje typ <code>post/</code> reprezentujący wpis blogu.
Każdy plik wejściowy jest opatrzony metadanymi zawierającymi tytuł, datę utworzenia itp.
Sposób formatowania tych metadanych zawierają pliki zaimportowane z przykładowego serwisu.
W kontekście dalszej pracy istotna jest flaga <code>draft</code></p>
<pre><code class="language-txt">---
...
draft: yes
---
</code></pre>
<p>Pliki z tą flagą są wyłączane z zawartości serwisu przeznaczonego do publikacji.
Zatem, aby uniknąć publikacji zaimportowanych przykładowych plików należy w każdym z nich ustawić tę flagę.</p>
<p>Kolejnym elementem, którego edycja jest niezbędna, jest plik <code>hugo.toml</code>.
Należy w nim ustawić URL pod którym będzie dostępny serwis.
Jeżeli wartość zmiennej <code>baseURL</code> jest ustawiona na</p>
<pre><code class="language-toml">baseURL = &quot;https://your_gh_account.github.io/gh_repo/&quot;
</code></pre>
<p>to podgląd generowanych na bieżąco stron będzie dostępny pod adresem
<a href="http://localhost:1313/gh_repo" target="_blank">http://localhost:1313/gh_repo</a>.
Plik konfiguracyjny zawiera również wiele innych zmiennych, których nazwy i warości silnie zależą od użytego stylu serwisu.</p>
<p>Ostatnim z obowiązkowych kroków jest przygotowanie nowego wpisu.
<code>Hugo</code> umożliwia przygotowanie jego szablonu.
W katalogu projektu (terminal <code>Code</code>) należy wydać komendę</p>
<pre><code class="language-sh">hugo new post/to-moj-pierwszy-wpis.md
</code></pre>
<p>która utworzy w katalogu <code>post/</code> plik <code>Markdown</code> o treści</p>
<pre><code class="language-markdown">---
title: &quot;To Moj Pierwszy Wpis&quot;
date: 2023-08-05T17:18:23Z
draft: true
---
</code></pre>
<p>Plik ten należy uzupełnić treścią.
Przy formatowaniu wpisu (treść, metadane) najlepiej kierować się przykładami zawartymi w szablonie serwisu.
W niektórych szablonach streszczenia nowych wpisów pojawiają się na stronie głównej serwisu.
Streszczenie oddziela się od treści głównej umieszczając w pliku wejściowym <code>Markdown</code> znacznik <a href="https://gohugo.io/content-management/summaries/#summary-selection-order" target="_blank">read more</a>.</p>
<p>Więcej informacji nt. prawidłowego przygotowania plików dla generatora jest dostępnych na stronie <a href="https://gohugo.io/content-management/" target="_blank">projektu Hugo</a>.
Przykłady zawarte w użytym szablonie serwisu również mogą być pomocne.</p>
<h2 id="praca-ze-zdalnym-repozytorium">Praca ze zdalnym repozytorium</h2>
<p>Zdalne repozytorium <code>GitHub</code> może wykorzystać trojako: do synchronizacji katalogów roboczych na kilku różnych komputerach, do stworzenia kopii zapasowej projektu oraz do automatycznego generowania serwisu i jego publikacji. Ostatniemu zagadnieniu poświęcono <a href="#github-actions">osobną sekcję</a>.</p>
<p>Praca z repozytorium <code>GitHub</code> w <code>Code</code> nie nastręcza żadnych trudności bowiem w edytor wbudowano odpowiednie mechanizmy.
Pliki, które zmieniono względem ostatniej synchronizacji ze zdalnym repozytorium są oznaczane literką &ldquo;U&rdquo;.
Aby zsynchronizować się zdalnym repozytorium należy na panelu bocznym wybrać ikonę współdzielenia.
Synchronizacja odbywa się w paczkach zwanych &ldquo;Commit&rdquo;.
Każdy &ldquo;Commit&rdquo; jest opatrzony krótkim opisem, zatem mechanizm ten umożliwia aktualizację repozytorium w sposób zorientowany problemowo.
Aby plik znalazł się w danej paczce &ldquo;Commit&rdquo;, musi najpierw zostać przeniesiony do poczekalni (tzw. <em>stage</em>).
Po wybraniu ikony współdzielenia prezentowana jest lista zmienionych plików projektu.
Z listy tej można wybrać pliki, które zostają wystawione do aktualizacji (<em>stage</em>).
Następnie, w górnej linii panelu bocznego należy wpisać opis paczki, a następnie wybrać &ldquo;Commit&rdquo;.
Paczek &ldquo;Commit&rdquo; można utworzyć kilka.
Aktualizację ze zdalnym repozytorium realizuje wybranie przycisku &ldquo;Sync&rdquo;.</p>
<p><code>Git</code> umożliwia wyłączenie wybranych plików z mechanizmu synchronizacji.
Są one określone w pliku <code>.gitignore</code>, przy czym dozwolone jest stosowanie standardowych masek powłoki w postaci znaków &ldquo;?&rdquo; i &ldquo;*&rdquo;.
Typowa postać tego pliku dla repozytorium zawierające projekt statycznego serwisu <code>Hugo</code> ma postać</p>
<pre><code class="language-txt">resources/_gen/*
themes/*/exampleSite/*
.vscode/
public/*
</code></pre>
<p>Katalog <code>resources/</code> zawiera pliki pośrednie wykorzystane przez generator, natomiast katalog <code>public/</code> pliki wynikowe.
Jeżeli repozytorium <code>GitHub</code> ma być wykorzystane do publikacji gotowego serwisu wygenerowanego lokalnie, to oczywiście katalog <code>public/</code> należy usunąć z pliku <code>.gitignore</code>.</p>
<h2 id="publikacja-serwisu">Publikacja serwisu</h2>
<p>Publikacja serwisu wymaga wykonania dwóch czynności: wygenerowania stron HTML oraz umieszczenia ich na dostępnym publicznie serwerze WWW.
Dalej opisano dwa podejścia.
Pierwsze wykorzystuje usługi serwisu GitHub.
Serwis GitHub, podobnie do GitLab i kilku innych serwisów wspierających pracę grupową nad projektami, zawiera usługi ciągłej integracji zmian i dostarczania nowych wersji oprogramowania (CI/CD).
W środowisku <code>GitHub</code> usługa ta nosi nazwę <code>GitHub Actions</code>.
Za jej pomocą można uaktywnić automatyczną generację zawartości serwisu po każdorazowej aktualizacji repozytorium i udostępnić jego zawartość korzystając z mechanizmu <code>GitHub Pages</code>.
Serwis będzie dostępny pod adresem</p>
<pre><code class="language-txt">https://your_gh_account.github.io/gh_repo/
</code></pre>
<p>Poza konfiguracją mechanizmu CI/CD żadna dodatkowa konfiguracja nie jest potrzebna.
Usługi <code>GitHub Actions</code> i <code>GitHub Pages</code> są dostępne nieodpłatnie dla repozytoriów publicznych.</p>
<p>Drugie z opisanych podejść opisuje działania niezbędne do realizacji własnego hostingu.
Do jego realizacji potrzebna będzie maszyna z publicznym (routowalnym) adresem IP. Nie ma wymogu aby adres ten był stały.  Maszyna musi mieć skonfigurowany dostęp za pomocą protokołu SSH.
Do hostingu wykorzystane zostaną kontenery <code>Docker</code>, zatem również konieczna jest instalacja tego serwera na maszynie publikującej serwis WWW.
Nic nie stoi na przeszkodzie, aby maszyna wykorzystana do publikacji była zrealizowana jako wirtualny host w chmurze.
Serwis WWW musi mieć swoją nazwę, zatem należy wykupić domenę lub skorzystać z darmowych odmian dynamicznych serwisów DNS do skojarzenia nazwy serwisu z adresem IP maszyny udostępniającej serwis.
W prezentowanym dalej przykładzie zostanie wykorzystana usługa <code>DuckDNS</code>.</p>
<h3 id="a-namegithub-actionsagithub-pages-i-github-actions"><a name="github-actions"></a>GitHub Pages i GitHub Actions</h3>
<p>Pierwotnie usługi <code>GitHub Pages</code> i <code>GitHub Actions</code> były realizowane za pomocą osobnych mechanizmów.
Obecnie <code>GitHub Pages</code> jest realizowane za pomocą wyspecjalizowanych akcji z usługi <code>GitHub Actions</code>.
Innymi słowy, publikacja stron WWW to obecnie jedna z automatycznych akcji jakie mogą być podjęte po zmianie zawartości repozytorium.</p>
<h4 id="serwis-generowany-lokalnie-publikacja-statycznych-stron">Serwis generowany lokalnie, publikacja statycznych stron</h4>
<p>W najprostszym przypadku jesteśmy zainteresowani tylko publikacją gotowych stron wygenerowanych lokalnie w środowisku <code>Code</code> i umieszczonych w ramach synchronizacji w repozytorium <code>GitHub</code>.
<code>Hugo</code> generuje pliki wyjściowe w katalogu <code>public</code>, zatem tylko te pliki powinny zostać przeniesione do serwisu <code>GitHub Pages</code>.</p>
<p>Konfigurowanie mechanizmu publikacji należy rozpocząć od skonfigurowania <code>GitHub Pages</code>.</p>
<ul>
<li>
<p>Po pierwsze w repozytorium musi w repozytorium istnieć gałąź <code>Git</code> o nazwie <code>gh-pages</code>.
Można ją utworzyć w serwisie <code>GitHub</code> wybierając na stronie głównej repozytorium przycisk <code>Branches</code>.
Alternatywnie można wykorzystać <code>Code</code>.
Po wybraniu ikony synchronizacji wybieramy <code>...</code> przy nazwie repozytorium , a następnie <code>Branch</code>-&gt; <code>Create Branch</code> i wpisujemy <code>gh-pages</code>.
Teraz utworzoną gałąź publikujemy (<code>...</code>-&gt;<code>Branch</code>-&gt;<code>Publish Branch</code>), co zapewni, że zostanie ona przeniesiona do drzewa <code>Git</code> znajdującego się w repozytorium <code>GitHub</code>.</p>
</li>
<li>
<p>Funkcjonalność publikacji zawartości repozytorium należy również aktywować w jego ustawieniach.
Należy otworzyć stronę</p>
<pre><code class="language-txt">https://github.com/${gh_user}/${gh_repo}/settings/pages
</code></pre>
<p>i jako sposób publikacji (<code>Build and deployment</code>) należy wybrać <code>GitHub Actions</code> oraz opcję <code>Static HTML</code>.
W repozytorium zostanie utworzony plik</p>
<pre><code class="language-txt">.github/workflows/static.yml
</code></pre>
</li>
</ul>
<p>Domyślnie akcja publikacji dotyczy zawartości całego repozytorium.
Generator umieszcza pliki wynikowe w podkatalogu <code>public/</code>, zatem należy zaktualizować zmienną <code>path</code> w pliku konfiguracyjnym akcji <code>static.yml</code></p>
<pre><code class="language-yaml">name: Deploy static content to Pages
on:
  push:
    branches: [&quot;main&quot;]
  workflow_dispatch:
permissions:
  contents: read
  pages: write
  id-token: write
concurrency:
  group: &quot;pages&quot;
  cancel-in-progress: false
jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Setup Pages
        uses: actions/configure-pages@v3
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          # Upload only 'public/' folder
          path: 'public/'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2
</code></pre>
<h4 id="serwisu-generowany-zdalnie-i-automatycznie-publikowany">Serwisu generowany zdalnie i automatycznie publikowany</h4>
<p>Serwis <code>GitHub</code> umożliwia wykonywanie zautomatyzowanych działań na plikach repozytorium gdy nastąpi jakieś zdarzenie.
Jednym ze zdarzeń, które mogą aktywować działanie jest zmiana zawartości repozytorium.
Do realizacji automatycznych działań wykorzystywane są kontenery Dockera uruchamiane w chmurze.
Wiele typowych akcji jest już skonfigurowanych i wystarczy tylko się do nich odwołać w konfiguracji repozytorium.
Możliwa jest zatem konfiguracja, w której aktualizacja plików wejściowych generatora <code>Hugo</code> spowoduje zbudowanie serwisu WWW przy użyciu kontenera zawierającego generator, a następnie publikacja wyniku jego działania przy użyciu metody opisanej w poprzednim punkcie.
Ponownie w <code>Pages</code> wybrać <code>GitHub Actions</code> należy jako metodę publikacji serwisu. Jednak tym razem należy wybrać zaproponowany wzorzec działania <code>Hugo</code> (Zmiana metody publikacji serwisu wymaga wcześniejszego  wyłączenia.)</p>
<pre><code class="language-yaml">name: Deploy Hugo site to Pages
on:
  push:
    branches: [&quot;main&quot;]
  workflow_dispatch:
permissions:
  contents: read
  pages: write
  id-token: write
concurrency:
  group: &quot;pages&quot;
  cancel-in-progress: false
defaults:
  run:
    shell: bash
jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    env:
      HUGO_VERSION: 0.114.0
    steps:
      - name: Install Hugo CLI
        run: |
          wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \
          &amp;&amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb
      - name: Install Dart Sass
        run: sudo snap install dart-sass
      - name: Checkout
        uses: actions/checkout@v3
        with:
          submodules: recursive
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v3
      - name: Install Node.js dependencies
        run: &quot;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] &amp;&amp; npm ci || true&quot;
      - name: Build with Hugo
        env:
          # For maximum backward compatibility with Hugo modules
          HUGO_ENVIRONMENT: production
          HUGO_ENV: production
        run: |
          hugo \
            --minify \
            --baseURL &quot;${{ steps.pages.outputs.base_url }}/&quot;
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v2
        with:
          path: ./public
  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v2
</code></pre>
<p>Biorąc pod uwagę, że skonfigurowana akcja zapewnia generację plików HTML, to nie jest już konieczna synchronizacja plików z podkatalogu <code>public</code>.
W przyjętej konfiguracji każdorazowa zmiana zawartości gałęzi main w repozytorium spowoduje wygenerowanie nowej wersji serwisu.
Status wykonanych działań można śledzić na stronie</p>
<pre><code class="language-txt">https://github.com/your_gh_account/gh_repo/actions
</code></pre>
<p>Wygenerowany serwis jest dostepny pod adresem</p>
<pre><code class="language-txt">https://your_gh_account.github.io/gh_repo/
</code></pre>
<h3 id="własny-hosting-serwisu">Własny hosting serwisu</h3>
<p>Do realizacji lokalnego hostingu jakiekolwiek serwisu niezbędny jest routowalny (publiczny) adres IP.
W omawianej konfiguracji przyjęto założenie, że adres ten jest przypisany do routera z usługą NAT, natomiast host realizujący serwis znajduje się w sieci lokalnej &ldquo;schowanej&rdquo; za routerem i korzystającej nieroutowalnych (prywatnych) adresów IP.
Przyjęto również założenie, że host, na którym rozwijany jest serwis i na którym zainstalowano <code>Code</code>, znajduje się w tej samej sieci co host z serwisem WWW.
Na hoście z serwisem WWW działa serwer SSH.</p>
<p>Do publicznego adresu IP musi być przypisana kwalifikowana domenowa nazwa hosta (FQDN) w formacie <code>nazwa.serwisu.moja.domena.org</code>.
Jeżeli adres IP jest stały, to wystarczy wykupić dla niego domenę.
Dla adresów zmiennych konieczne jest skorzystanie z usługi dynamicznego DNS.
Idea działania takiej usługi polega na tym, że host o zmiennym adresie IP otrzymuje identyfikator unikalny w ramach dynamicznego serwisu DNS i co pewien czas &ldquo;melduje&rdquo; swój adres IP.
Usługa dynamicznego DNS rozpowszechnia tę informację, komunikując się z innymi serwisami DNS, które aktualizują swoją konfigurację.
Oczywiście, dla stałych adresów IP skorzystanie z usługi dynamicznego DNS do uzyskania nazwy domenowej jest również możliwe.
Darmowe usługi dynamicznego DNS pozwalają zazwyczaj tylko na określenie nazwy hosta, a  domenowa część nazwy jest zadana przez dostawcę serwisu.</p>
<p>Zaproponowana konfiguracja hosta realizującego serwis pozwala na prowadzenie wielu serwisów WWW na tym samym adresie IP, jednak o różnych nazwach domenowych.
Oczywiście nic nie stoi na przeszkodzie, aby do tego samego numeru IP przypisać wiele nazw domenowych.
Dalej do skojarzenia adresu IP z nazwą domenową wykorzystany darmowy serwis <code>https://duckdns.org</code>.
W serwisie należy założyć konto.
W ramach każdego konta można nieodpłatnie założyć kilka domen (wraz z subdomenami).
Każdy użytkownik serwisu ma przypisany unikalny token, który jest wykorzystywany do aktualizacji zmiennego adresu IP.</p>
<p>Na hoście, który ma utrzymywać serwis www konieczna jest instalacja <a href="https://docs.docker.com/engine/install/" target="_blank">serwera Dockera</a>.
Użytkownik zdalnego hosta powinien być dodany do grupy <code>docker</code>, co uwolnia od konieczności pracy z Dockerem na prawach administratora.</p>
<pre><code class="language-sh">sudo usermod -aG docker ${USER}
</code></pre>
<p>Aby powyższa zmiana odniosła skutek, należy się wylogować i zalogować lub w otwartych sesjach wydać komendę</p>
<pre><code class="language-sh">newgrp docker
</code></pre>
<p>W zdalnym zarządzaniu kontenerami dobrze spisuje się <a href="https://www.portainer.io/" target="_blank"><code>Portainer</code></a>.
Uboższa jego wersja jest <a href="https://docs.portainer.io/start/install-ce/server/docker" target="_blank">dostępna nieodpłatnie</a>.
Instalacja sprowadza się do dwóch komend</p>
<pre><code class="language-sh">docker volume create portainer_data
docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest
</code></pre>
<p>Od teraz zainstalowanymi obrazami i kontenerami można zarządzać łącząc się przeglądarką przy użyciu protokołu <code>HTTP</code> z portem <code>9000</code> hosta z Portainerem.</p>
<p>Instalacja własnego serwisu WWW jest bardzo prosta.
Do katalogu <code>services</code> hosta</p>
<pre><code class="language-sh">mkdir -p /home/your_host_account/services/
cd /home/your_host_account/services/
</code></pre>
<p>wgrywamy plik <code>docker-compose.yml</code> o następującej treści</p>
<pre><code class="language-yaml">version: &quot;3&quot;
networks:
  frontend:
    name: dmz

services:
  duckdns:
    image: lscr.io/linuxserver/duckdns:latest
    container_name: dmz-duckdns
    environment:
      - PUID=1000 #optional
      - PGID=1000 #optional
      - TZ=Europe/Warsaw
      - SUBDOMAINS=zawadzki,zawadzka
      - TOKEN=xxxxxxxx-yyyy-zzzz-aaaa-bbbbbbbbbbbb
      - LOG_FILE=true #optional
    volumes:
      - /home/your_host_account/services/duckdns:/config #optional
    networks:
     - frontend
    restart: unless-stopped

  nginxproxy:
    image: 'jc21/nginx-proxy-manager:latest'
    container_name: dmz-nginxproxy
    restart: unless-stopped
    ports:
      - '8888:80'
      - '81:81'
      - '4443:443'
    volumes:
      - /home/your_host_account/services/npm/data:/data
      - /home/your_host_account/services/npm/letsencrypt:/etc/letsencrypt
    networks:
      - frontend

  www0:
    image: lscr.io/linuxserver/nginx:latest
    container_name: dmz-www0
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/London
    volumes:
      - /home/your_host_account/services/www0:/config
    restart: unless-stopped
    networks:
      - frontend

  www1:
    image: lscr.io/linuxserver/nginx:latest
    container_name: dmz-www1
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/London
    volumes:
      - /home/your_host_account/services/www1:/config
    restart: unless-stopped
    networks:
      - frontend
</code></pre>
<p>Następnie należy utworzyć puste katalogi, w których będą przechowywane dane z kontenerów</p>
<pre><code class="language-sh">mkdir -p {duckdns,npm/data,npm/letsencrypt,www0,www1}
</code></pre>
<p>Ostateczne uruchomienie stosu usług realizuje komenda</p>
<pre><code class="language-sh">docker compose up -d
</code></pre>
<p>wydana w katalogu z plikiem <code>docker-compose.yml</code>.</p>
<p>Kontener <code>duckdns</code> odpowiada za aktualizację adresu IP serwisu w usłudze dynamicznego DNS.
Kontener <code>nginx-proxy-manager</code> realizuje <code>reverse-proxy</code>, za którym schowane są serwisy <code>www0</code> i <code>www1</code>.
Kontener ten również troszczy się o utrzymanie aktualnego certyfikatu dla domen skonfigurowanych w ramach proxy.
Zarządzanie proxy (i domenami) realizuje się za pomocą interfejsu WWW dostępnego na porcie <code>81</code>.
Interfejsy <code>http</code> i <code>https</code> zarządzanych usług dostępne są odpowiednio na portach <code>8888</code> i <code>4443</code> dlatego na routerze realizującym NAT należy uaktywnić <code>Port Forwarding</code> i zrealizować przypisanie &ldquo;80-&gt;ip_host:8888&rdquo;, &ldquo;443-&gt;ip_host:4443&rdquo;.
W ten sposób ruch docierający do routera i skojarzony z protokołami <code>http</code> i <code>https</code> zostanie przekierowany do usługi <code>proxy</code>, a ta, na podstawie nazwy domenowej, podejmie decyzję do którego serwisu WWW ruch powinien być skierowany.
Wspomniane przekierowanie portów musi być wykonane <strong>przed</strong> konfiguracją proxy, bowiem są one wykorzystywane do komunikacji z serwisem <code>LetsEncrypt</code> w celu uzyskania certyfikatów SSL.</p>
<p>Konfiguracja <code>Nginx Proxy Manager</code> jest stosunkowo prosta.
Pierwsze łączenie z interfejsem administracyjnym (port 81) wymaga zmiany hasła i nazwy użytkownika (domyślnymi wartościami są <code>admin</code> i <code>changeme</code>).
Konfigurację rozpoczynamy od uzyskania certyfikatów dla skonfigurowanych domen (<code>Dashboard-&gt;SSL Certificates</code>).
Następnie dodajemy <code>Proxy Hosts</code>. Jako nazwę <code>Forward Hostname</code> należy podać nazwę kontenera,czyli w rozważanym przypadku <code>dmz-www0</code> lub <code>dmz-www1</code>.</p>
<p>Środowisko do prezentacji zawartości serwisu jest już przygotowane.
Należy jedynie pamiętać, aby w konfiguracji <code>Hugo</code> (<code>config.toml</code>) również ustawić nazwę skonfigurowaną w <code>DuckDNS</code>.
Serwis generuje się jak zwykle, zatrzymując serwer i wydając w katalogu projektu komendę</p>
<pre><code class="language-sh">hugo

</code></pre>
<p>Wystarczy teraz przesłać zawartość katalogu <code>public/</code> do katalogu głównego serwera WWW tj.</p>
<pre><code class="language-sh">scp -r public/* user@ip_host_lan:/home/your_host_account/services/www1/www/
</code></pre>
<p>i serwis jest opublikowany.</p>
<h2 id="podsumowanie">Podsumowanie</h2>
    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>O ile nie zaznaczono inaczej, zawartość tej witryny jest objęta licencją <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a>.</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Strony</h3>
        <ul>
            
            <li>
                <a href="/pejotzet/">Home</a>
            </li>
            
            <li>
                <a href="/pejotzet/about/">About</a>
            </li>
            
            <li>
                <a href="/pejotzet/search/">Search</a>
            </li>
            
            <li>
                <a href="/pejotzet/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Linki</h3>
        <ul>
            
            <li>
                <a href="https://github.com/pejotzet" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tagi</h3>
        <div>
            
            <span>
                <a href="/pejotzet/tags/code/">Code</a>
            </span>
            
            <span>
                <a href="/pejotzet/tags/devcontainer/">DevContainer</a>
            </span>
            
            <span>
                <a href="/pejotzet/tags/github-actions/">Github Actions</a>
            </span>
            
            <span>
                <a href="/pejotzet/tags/hugo/">Hugo</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Spis Treści</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#czynności-wstępne">Czynności wstępne</a>
      <ul>
        <li><a href="#przygotowanie-folderu-projektu">Przygotowanie folderu projektu</a></li>
        <li><a href="#przygotowanie-szablonu-serwisu">Przygotowanie szablonu serwisu</a></li>
      </ul>
    </li>
    <li><a href="#przygotowanie-treści-serwisu">Przygotowanie treści serwisu</a></li>
    <li><a href="#praca-ze-zdalnym-repozytorium">Praca ze zdalnym repozytorium</a></li>
    <li><a href="#publikacja-serwisu">Publikacja serwisu</a>
      <ul>
        <li><a href="#a-namegithub-actionsagithub-pages-i-github-actions"><a name="github-actions"></a>GitHub Pages i GitHub Actions</a></li>
        <li><a href="#własny-hosting-serwisu">Własny hosting serwisu</a></li>
      </ul>
    </li>
    <li><a href="#podsumowanie">Podsumowanie</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Strony</h3>
        <ul>
            
            <li>
                <a href="/pejotzet/">Home</a>
            </li>
            
            <li>
                <a href="/pejotzet/about/">About</a>
            </li>
            
            <li>
                <a href="/pejotzet/search/">Search</a>
            </li>
            
            <li>
                <a href="/pejotzet/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Linki</h3>
        <ul>
            
            <li>
                <a href="https://github.com/pejotzet" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tagi</h3>
        <div>
            
            <span>
                <a href="/pejotzet/tags/code/">Code</a>
            </span>
            
            <span>
                <a href="/pejotzet/tags/devcontainer/">DevContainer</a>
            </span>
            
            <span>
                <a href="/pejotzet/tags/github-actions/">Github Actions</a>
            </span>
            
            <span>
                <a href="/pejotzet/tags/hugo/">Hugo</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>Spis Treści</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#czynności-wstępne">Czynności wstępne</a>
      <ul>
        <li><a href="#przygotowanie-folderu-projektu">Przygotowanie folderu projektu</a></li>
        <li><a href="#przygotowanie-szablonu-serwisu">Przygotowanie szablonu serwisu</a></li>
      </ul>
    </li>
    <li><a href="#przygotowanie-treści-serwisu">Przygotowanie treści serwisu</a></li>
    <li><a href="#praca-ze-zdalnym-repozytorium">Praca ze zdalnym repozytorium</a></li>
    <li><a href="#publikacja-serwisu">Publikacja serwisu</a>
      <ul>
        <li><a href="#a-namegithub-actionsagithub-pages-i-github-actions"><a name="github-actions"></a>GitHub Pages i GitHub Actions</a></li>
        <li><a href="#własny-hosting-serwisu">Własny hosting serwisu</a></li>
      </ul>
    </li>
    <li><a href="#podsumowanie">Podsumowanie</a></li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2023-2023
                <a href="https://pejotzet.github.io/pejotzet">PeJotZet</a>
                 | <a href="https://pejotzet.github.com/hugodev">Source code</a> 
                | Wspierane Przez <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js" integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js" integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin="anonymous"></script>



<script defer src="/pejotzet/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js" integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8&#43;XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ&#43;Ao0UlWGqODw=="></script>



</body>

</html>
